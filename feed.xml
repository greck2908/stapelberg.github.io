<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Michael Stapelbergs Website</title>
  <link href="https://michael.stapelberg.de/feed.xml" rel="self"/>
  <link href="https://michael.stapelberg.de/"/>
  <updated>2017-12-11T10:05:00+01:00</updated>
  <id>https://michael.stapelberg.de/</id>
  <generator>Hugo -- gohugo.io</generator>
  <entry>
    <title type="html"><![CDATA[TurboPFor: an analysis]]></title>
    <link href="https://michael.stapelberg.de/posts/2019-02-05-turbopfor-analysis/"/>
    <id>https://michael.stapelberg.de/posts/2019-02-05-turbopfor-analysis/</id>
    <published>2019-02-05T09:00:00+01:00</published>
    <updated>2019-02-05T09:18:07+01:00</updated>
    <content type="html"><![CDATA[

<h3 id="motivation">Motivation</h3>

<p>I have recently been looking into speeding up Debian Code Search. As a quick
reminder, search engines answer queries by consulting an inverted index: a map
from term to documents containing that term (called a “posting list”). See <a href="https://codesearch.debian.net/research/bsc-thesis.pdf">the
Debian Code Search Bachelor
Thesis</a> (PDF) for a lot
more details.</p>

<p>Currently, Debian Code Search does not store positional information in its
index, i.e. the index can only reveal <em>that</em> a certain trigram is present in a
document, not <em>where</em> or <em>how often</em>.</p>

<p>From analyzing Debian Code Search queries, I knew that identifier queries (70%)
massively outnumber regular expression queries (30%). When processing identifier
queries, storing positional information in the index enables a significant
optimization: instead of identifying the possibly-matching documents and having
to read them all, we can determine matches from querying the index alone, no
document reads required.</p>

<p>This moves the bottleneck: having to read all possibly-matching documents
requires a lot of expensive random I/O, whereas having to decode long posting
lists requires a lot of cheap sequential I/O.</p>

<p>Of course, storing positions comes with a downside: the index is larger, and a
larger index takes more time to decode when querying.</p>

<p>Hence, I have been looking at various posting list compression/decoding
techniques, to figure out whether we could switch to a technique which would
retain (or improve upon!) current performance despite much longer posting lists
and produce a small enough index to fit on our current hardware.</p>

<h3 id="literature">Literature</h3>

<p>I started looking into this space because of Daniel Lemire’s <a href="https://lemire.me/blog/2017/09/27/stream-vbyte-breaking-new-speed-records-for-integer-compression/">Stream
VByte</a>
post. As usual, Daniel’s work is well presented, easily digestible and
accompanied by not just one, but multiple implementations.</p>

<p>I also looked for scientific papers to learn about the state of the art and
classes of different approaches in general. The best I could find is
<a href="https://dl.acm.org/citation.cfm?doid=2682862.2682870">Compression, SIMD, and Postings
Lists</a>. If you don’t have
access to the paper, I hear that
<a href="https://en.wikipedia.org/wiki/Sci-Hub">Sci-Hub</a> is helpful.</p>

<p>The paper is from 2014, and doesn’t include all algorithms. If you know of a
better paper, please let me know and I’ll include it here.</p>

<p>Eventually, I stumbled upon an algorithm/implementation called TurboPFor, which
the rest of the article tries to shine some light on.</p>

<h3 id="turbopfor">TurboPFor</h3>

<p>If you’re wondering: PFor stands for Patched Frame Of Reference and describes a
family of algorithms. The principle is explained e.g. in <a href="https://arxiv.org/pdf/1401.6399.pdf">SIMD Compression and
the Intersection of Sorted Integers (PDF)</a>.</p>

<p>The <a href="https://github.com/powturbo/TurboPFor">TurboPFor project’s README file</a>
claims that TurboPFor256 compresses with a rate of 5.04 bits per integer, and
can decode with 9400 MB/s on a single thread of an Intel i7-6700 CPU.</p>

<p>For Debian Code Search, we use unsigned integers of 32 bit (uint32), which
TurboPFor will compress into as few bits as required.</p>

<p>Dividing Debian Code Search’s file sizes by the total number of integers, I get
similar values, at least for the docid index section:</p>

<ul>
<li>5.49 bits per integer for the docid index section</li>
<li>11.09 bits per integer for the positions index section</li>
</ul>

<p>I can confirm the order of magnitude of the decoding speed, too. My benchmark
calls TurboPFor from Go via cgo, which introduces some overhead. To exclude disk
speed as a factor, data comes from the page cache. The benchmark sequentially
decodes all posting lists in the specified index, using as many threads as the
machine has cores¹:</p>

<ul>
<li>≈1400 MB/s on a  1.1 GiB docid index section</li>
<li>≈4126 MB/s on a 15.0 GiB position index section</li>
</ul>

<p>I think the numbers differ because the position index section contains larger
integers (requiring more bits). I repeated both benchmarks, capped to 1 GiB, and
decoding speeds still differed, so it is not just the size of the index.</p>

<p>Compared to Streaming VByte, a TurboPFor256 index comes in at just over half the
size, while still reaching 83% of Streaming VByte’s decoding speed. This seems
like a good trade-off for my use-case, so I decided to have a closer look at how
TurboPFor works.</p>

<p>① See <a href="https://github.com/stapelberg/goturbopfor/blob/d7954fb81e66080941891dccc27407d8496f65d9/cmd/gp4-verify/verify.go">cmd/gp4-verify/verify.go</a> run on an Intel i9-9900K.</p>

<h3 id="methodology">Methodology</h3>

<p>To confirm my understanding of the details of the format, I implemented a
pure-Go TurboPFor256 decoder. Note that it is intentionally <em>not optimized</em> as
its main goal is to use simple code to teach the TurboPFor256 on-disk format.</p>

<p>If you’re looking to use TurboPFor from Go, I recommend using cgo. cgo’s
function call overhead is about 51ns <a href="https://go-review.googlesource.com/c/go/+/30080">as of Go
1.8</a>, which will easily be
offset by TurboPFor’s carefully optimized, vectorized (SSE/AVX) code.</p>

<p>With that caveat out of the way, you can find my teaching implementation at
<a href="https://github.com/stapelberg/goturbopfor">https://github.com/stapelberg/goturbopfor</a></p>

<p>I verified that it produces the same results as TurboPFor’s <code>p4ndec256v32</code>
function for all posting lists in the Debian Code Search index.</p>

<h3 id="on-disk-format">On-disk format</h3>

<p>Note that TurboPFor does not fully define an on-disk format on its own. When
encoding, it turns a list of integers into a byte stream:</p>

<pre><code>size_t p4nenc256v32(uint32_t *in, size_t n, unsigned char *out);
</code></pre>

<p>When decoding, it decodes the byte stream into an array of integers, but needs
to know the number of integers in advance:</p>

<pre><code>size_t p4ndec256v32(unsigned char *in, size_t n, uint32_t *out);
</code></pre>

<p>Hence, you’ll need to keep track of the number of integers and length of the
generated byte streams separately. When I talk about on-disk format, I’m
referring to the byte stream which TurboPFor returns.</p>

<p>The TurboPFor256 format uses blocks of 256 integers each, followed by a trailing
block — if required — which can contain fewer than 256 integers:</p>

<p><img src="/turbopfor/ondisk.svgo.svg"></p>

<p>SIMD bitpacking is used for all blocks but the trailing block (which uses
regular bitpacking). This is not merely an implementation detail for decoding:
the on-disk structure is different for blocks which can be SIMD-decoded.</p>

<p>Each block starts with a 2 bit header, specifying the type of the block:</p>

<ul>
<li>11: <a href="#block-constant">constant</a></li>
<li>00: <a href="#block-bitpack">bitpacking</a></li>
<li>10: <a href="#block-bitpackex">bitpacking with exceptions (bitmap)</a></li>
<li>01: <a href="#block-bitpackvb">bitpacking with exceptions (variable byte)</a></li>
</ul>

<p>Each block type is explained in more detail in the following sections.</p>

<p>Note that none of the block types store the number of elements: you will always
need to know how many integers you need to decode. Also, you need to know in
advance how many bytes you need to feed to TurboPFor, so you will need some sort
of container format.</p>

<p>Further, TurboPFor automatically choses the best block type for each block.</p>

<h4 id="block-constant">Constant block</h4>

<p>A constant block (all integers of the block have the same value) consists of a
single value of a specified bit width ≤ 32. This value will be stored in each
output element for the block. E.g., after calling <code>decode(input, 3, output)</code>
with <code>input</code> being the constant block depicted below, output is <code>{0xB8912636,
0xB8912636, 0xB8912636}</code>.</p>

<p><img src="/turbopfor/block-constant.svgo.svg"></p>

<p>The example shows the maximum number of bytes (5). Smaller integers will use
fewer bytes: e.g. an integer which can be represented in 3 bits will only use 2
bytes.</p>

<h4 id="block-bitpack">Bitpacking block</h4>

<p>A bitpacking block specifies a bit width ≤ 32, followed by a stream of
bits. Each value starts at the Least Significant Bit (LSB), i.e. the 3-bit
values 0 (<code>000b</code>) and 5 (<code>101b</code>) are encoded as <code>101000b</code>.</p>

<p><img src="/turbopfor/block-bitpack.svgo.svg"></p>

<h4 id="block-bitpackex">Bitpacking with exceptions (bitmap) block</h4>

<p>The constant and bitpacking block types work well for integers which don’t
exceed a certain width, e.g. for a series of integers of width ≤ 5 bits.</p>

<p>For a series of integers where only a few values exceed an otherwise common
width (say, two values require 7 bits, the rest requires 5 bits), it makes sense
to cut the integers into two parts: value and exception.</p>

<p>In the example below, decoding the third integer <code>out2</code> (<code>000b</code>) requires
combination with exception <code>ex0</code> (<code>10110b</code>), resulting in <code>10110000b</code>.</p>

<p>The number of exceptions can be determined by summing the 1 bits in the bitmap
using the <a href="https://en.wikipedia.org/wiki/Hamming_weight">popcount instruction</a>.</p>

<p><img src="/turbopfor/block-bitpackex.svgo.svg"></p>

<h4 id="block-bitpackvb">Bitpacking with exceptions (variable byte)</h4>

<p>When the exceptions are not uniform enough, it makes sense to switch from
bitpacking to a variable byte encoding:</p>

<p><img src="/turbopfor/block-bitpackvb.svgo.svg"></p>

<h3 id="decoding-variable-byte">Decoding: variable byte</h3>

<p>The variable byte encoding used by the TurboPFor format is similar to the one
<a href="https://sqlite.org/src4/doc/trunk/www/varint.wiki">used by SQLite</a>, which is
described, alongside other common variable byte encodings, at
<a href="https://github.com/stoklund/varint">github.com/stoklund/varint</a>.</p>

<p>Instead of using individual bits for dispatching, this format classifies the
first byte (<code>b[0]</code>) into ranges:</p>

<ul>
<li>[0—176]: the value is <code>b[0]</code></li>
<li>[177—240]: a 14 bit value is in <code>b[0]</code> (6 high bits) and <code>b[1]</code> (8 low bits)</li>
<li>[241—248]: a 19 bit value is in <code>b[0]</code> (3 high bits), <code>b[1]</code> and <code>b[2]</code> (16 low bits)</li>
<li>[249—255]: a 32 bit value is in <code>b[1]</code>, <code>b[2]</code>, <code>b[3]</code> and possibly <code>b[4]</code></li>
</ul>

<p>Here is the space usage of different values:</p>

<ul>
<li>[0—176] are stored in 1 byte (as-is)</li>
<li>[177—16560] are stored in 2 bytes, with the highest 6 bits added to 177</li>
<li>[16561—540848] are stored in 3 bytes, with the highest 3 bits added to 241</li>
<li>[540849—16777215] are stored in 4 bytes, with 0 added to 249</li>
<li>[16777216—4294967295] are stored in 5 bytes, with 1 added to 249</li>
</ul>

<p>An overflow marker will be used to signal that encoding the
values would be less space-efficient than simply copying them
(e.g. if all values require 5 bytes).</p>

<p>This format is very space-efficient: it packs 0-176 into a single byte, as
opposed to 0-128 (most others). At the same time, it can be decoded very
quickly, as only the first byte needs to be compared to decode a value (similar
to PrefixVarint).</p>

<h3 id="decoding-bitpacking">Decoding: bitpacking</h3>

<h4 id="regular-bitpacking">Regular bitpacking</h4>

<p>In regular (non-SIMD) bitpacking, integers are stored on disk one after the
other, padded to a full byte, as a byte is the smallest addressable unit when
reading data from disk. For example, if you bitpack only one 3 bit int, you will
end up with 5 bits of padding.</p>

<p><img src="/turbopfor/bitpacking.svgo.svg"></p>

<h4 id="simd-bitpacking-256v32">SIMD bitpacking (256v32)</h4>

<p>SIMD bitpacking works like regular bitpacking, but processes 8 uint32
little-endian values at the same time, leveraging the <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX instruction
set</a>. The following
illustration shows the order in which 3-bit integers are decoded from disk:</p>

<p><img src="/turbopfor/bitpacking256v32.svgo.svg"></p>

<h3 id="in-practice">In Practice</h3>

<p>For a Debian Code Search index, 85% of posting lists are short enough to only
consist of a trailing block, i.e. no SIMD instructions can be used for decoding.</p>

<p>The distribution of block types looks as follows:</p>

<ul>
<li>72% bitpacking with exceptions (bitmap)</li>
<li>19% bitpacking with exceptions (variable byte)</li>
<li>5% constant</li>
<li>4% bitpacking</li>
</ul>

<p>Constant blocks are mostly used for posting lists with just one entry.</p>

<h3 id="conclusion">Conclusion</h3>

<p>The TurboPFor on-disk format is very flexible: with its 4 different kinds of
blocks, chances are high that a very efficient encoding will be used for most
integer series.</p>

<p>Of course, the flip side of covering so many cases is complexity: the format and
implementation take quite a bit of time to understand — hopefully this article
helps a little! For environments where the C TurboPFor implementation cannot be
used, smaller algorithms might be simpler to implement.</p>

<p>That said, if you can use the TurboPFor implementation, you will benefit from a
highly optimized SIMD code base, which will most likely be an improvement over
what you’re currently using.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Docker and IPv6]]></title>
    <link href="https://michael.stapelberg.de/posts/2018-12-12-docker-ipv6/"/>
    <id>https://michael.stapelberg.de/posts/2018-12-12-docker-ipv6/</id>
    <published>2018-12-12T09:54:00+01:00</published>
    <updated>2018-12-12T09:54:48+01:00</updated>
    <content type="html"><![CDATA[

<p>My use-case is seemingly very simple: I want to run a webserver in a Docker
container, and it should be reachable via IPv4 and IPv6. The webserver has
multiple virtual hosts, some of which just serve static files, while others
proxy to, say, a <a href="https://grafana.com">Grafana</a> instance, which is also running
in a Docker container.</p>

<p>This article walks through the required steps, which are a bit cumbersome to
puzzle together from Docker’s official documentation.</p>

<p>I’m using documentation-only IPs (<a href="https://tools.ietf.org/html/rfc3849">RFC3849</a>
and <a href="https://tools.ietf.org/html/rfc5737">RFC5737</a>) throughout the
article. Let’s say that my provider gives me a routed IPv6 subnet
<code>2001:db8:13b:330::/64</code> and the IPv4 address <code>203.0.113.1</code>.</p>

<h3 id="enabling-ipv6-in-docker">Enabling IPv6 in Docker</h3>

<p>The Docker daemon defaults to IPv4-only. To enable IPv6, create the
configuration file <code>/etc/docker/daemon.json</code> with the following content:</p>

<pre><code>{
  &quot;ipv6&quot;: true,
  &quot;fixed-cidr-v6&quot;: &quot;2001:db8:13b:330:ffff::/80&quot;
}
</code></pre>

<p>After restarting the Docker daemon, containers will now get IPv6 addresses based
on their MAC address, which is picked sequentially from the range
<code>02:42:ac:11:00:00</code> to <code>02:42:ac:11:ff:ff</code>. That is, the first container you
start will use the IPv6 address <code>2001:db8:13b:330:ffff:0242:ac11:0002</code>.</p>

<h3 id="publishing-ports-and-remote-addresses">Publishing ports and remote addresses</h3>

<p>When publishing port 80 of a webserver, notice the remote address when accessing
the port via IPv4 and IPv6:</p>

<pre><code>% docker run -p 80:80 nginx
198.51.100.7 - - [12/Dec/2018:07:38:19 +0000] &quot;GET / HTTP/1.1&quot; 200 612
172.17.0.1 - - [12/Dec/2018:07:38:40 +0000] &quot;GET / HTTP/1.1&quot; 200 612
</code></pre>

<p>The first request (IPv4) has the correct remote address, but not the second one
(IPv6). This is because Docker publishes ports with
<a href="https://en.wikipedia.org/wiki/Network_address_translation">NAT</a> for IPv4, and a
TCP proxy for IPv6.</p>

<p>Of course, not having access to the actual remote address breaks rate limiting,
abuse blocking, address-based geo location, etc.</p>

<p>Some people resort to using Docker’s <code>host</code> network option, but that’s not a
good solution: your container will not be able to talk to other containers by
name anymore, so you will need lots of static, host-specific configuration.</p>

<p>A better solution is to only publish the port via IPv4 and connect to the
container’s IPv6 address directly:</p>

<pre><code>% docker run --publish 203.0.113.1:80:80 --name nginx nginx
</code></pre>

<p>You can obtain the container’s IPv6 address using:</p>

<pre><code>% docker inspect -f '{{.NetworkSettings.GlobalIPv6Address}}' nginx
</code></pre>

<h3 id="static-ipv6-addresses">Static IPv6 addresses</h3>

<p>Above, I explained that we need to use the container’s IPv6 address directly,
and that the address is derived from the MAC address, which is chosen
sequentially at container start time.</p>

<p>Having addresses depend on the order in which containers come up isn’t a robust
solution for my simple setup, where I want to statically configure a DNS record.</p>

<p>Docker allows specifying an IPv6 address, but only when you’re using a <a href="https://docs.docker.com/network/network-tutorial-standalone/#use-user-defined-bridge-networks">user-defined bridge network</a> with an IPv6 subnet carved out for the network, like so:</p>

<pre><code>% docker network create --subnet 2001:db8:13b:330:dd::/80 --ipv6 nginx

% docker run \
  --network nginx \
  --ip6 2001:db8:13b:330:dd:ff::1 \
  --publish 203.0.113.1:80:80 \
  nginx
</code></pre>

<p>Note that I’m using an IPv6 address from the far end of the address space
(<code>ff::1</code>), so as to not conflict with the addresses that Docker sequentially
allocates from the network we created.</p>

<p>Now, create a DNS record with the container’s addresses and you’ll be able to
access it via IPv4 and IPv6 with correct remote addresses, while still being
able to reach other containers:</p>

<pre><code>www.example.net A    203.0.113.1
www.example.net AAAA 2001:db8:13b:330:dd:ff::1
</code></pre>

<p>Note that all other Docker containers that you want to reach from the nginx
container must also use the nginx network. This is the recommended solution over
the old <code>--link</code> flag anyway.</p>

<p>One disadvantage of this solution is that you cannot offer services from
multiple Docker containers on the same IPv6 address (e.g. www and git).</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Network setup for our retro computing event RGB2Rv18]]></title>
    <link href="https://michael.stapelberg.de/posts/2018-10-31-rgb2rv18-network/"/>
    <id>https://michael.stapelberg.de/posts/2018-10-31-rgb2rv18-network/</id>
    <published>2018-10-30T23:00:00+01:00</published>
    <updated>2019-01-26T21:47:38+01:00</updated>
    <content type="html"><![CDATA[

<p>Our computer association <a href="https://www.noname-ev.de/">NoName e.V.</a> organizes a
retro computing event called <a href="https://www.rgb2r.de/">RGB2R</a> every year,
located in Heidelberg, Germany. This year’s version is called RGB2Rv18.</p>

<p>This article describes the network setup I created for this year’s event. If you
haven’t read it, the article about <a href="/posts/2017-11-13-rgb2r-network/">last year’s RGB2Rv17
network</a> is also available.</p>

<h3 id="connectivity">Connectivity</h3>

<p>As a reminder, the venue’s DSL connection tops out at a megabit or two, so we
used my parent’s 400 Mbit/s cable internet line, like last year.</p>

<p>A difference to last year is that we switched from the tp-link CPE510 devices to
a pair of <a href="https://www.ubnt.com/airfiber/airfiber24/">Ubiquiti airFiber24</a>. The
airFibers are specified to reach 1.4 Gbit/s. In practice, we reached
approximately 700 Mbps displayed capacity (at a signal strength of ≈-60 dBm) and
422 Mbit/s end-to-end download speed, limited by the cable uplink.</p>

<p>Notably, using a single pair of radios removes a bunch of complexity from the
network setup as we no longer need to load-balance over two separate uplinks.</p>

<p>Like last year, the edge router for the event venue was a <a href="https://pcengines.ch/apu2c4.htm">PC Engines
apu2c4</a>. For the Local Area Network (LAN)
within the venue, we provided a few switches and WiFi using <a href="https://www.ubnt.com/">Ubiquiti
Networks</a> access points.</p>

<h3 id="wifi-setup">WiFi setup</h3>

<p>It turns out that the 24 GHz-based airFiber radios are much harder to align than
the 5 GHz-based tp-links we used last year. With the tp-link devices, we were
able to easily obtain a link, and do maybe 45 minutes of fine tuning to achieve
maximum bandwidth.</p>

<p>With the airFiber radios mounted in the same location, we were unable to
establish a link even once in about 1.5 hours of trying. We think this was due
to trees/branches being in the way, so we decided to scout the property for a
better radio location with as much of a direct line of sight as possible.</p>

<p>We eventually found a better location on the other side of the house and managed
to establish a link. It still took us an hour or so of fine tuning to move the
link from weak (≈-80 dBm) to okay (≈-60 dBm).</p>

<p>After the first night, in which it rained for a while, the radios had lost their
link. We think that this might be due to the humidity, and managed to restore
the link after another 30 minutes of re-adjustment.</p>

<p>It also rained the second night, but this time, the link stayed up. During rain,
signal strength dropped from ≈-60 dBm to ≈-72 dBm, but that still resulted in
≈500 Mbit/s of WiFi capacity, sufficient to max out our uplink.</p>

<p>For next year, it would be great to use an antenna alignment tool of sorts to
cut down on setup time. Alternatively, we could switch to more forgiving radios
which also handle 500 Mbps+. Let me know if you have any suggestions!</p>

<h3 id="software">Software</h3>

<p>In May this year, I wrote <a href="https://github.com/rtr7/router7">router7</a>, a pure-Go
small home internet router. Mostly out of curiosity, we gave it a shot, and I’m
happy to announce that router7 ran the event without any trouble.</p>

<p>In preparation, I <a href="https://github.com/rtr7/router7/commit/2e8e0daa0ac8a6a123893b27fb1de566768383d0">implemented TCP MSS
clamping</a>
and <a href="https://github.com/rtr7/kernel/commit/c7afbc1fd2efdb9e1149d271c4d2be59cc5c98f4">included the WireGuard kernel
module</a>.</p>

<p>I largely followed the <a href="https://github.com/rtr7/router7#installation">router7 installation
instructions</a>. To be specific,
here is the <code>Makefile</code> I used for creating the router7 image:</p>

<pre><code># github.com/rtr7/router7/cmd/... without dhcp6,
# as the cable uplink does not provide IPv6:
PKGS := github.com/rtr7/router7/cmd/backupd \
	github.com/rtr7/router7/cmd/captured \
	github.com/rtr7/router7/cmd/dhcp4 \
	github.com/rtr7/router7/cmd/dhcp4d \
	github.com/rtr7/router7/cmd/diagd \
	github.com/rtr7/router7/cmd/dnsd \
	github.com/rtr7/router7/cmd/netconfigd \
	github.com/rtr7/router7/cmd/radvd \
	github.com/gokrazy/breakglass \
	github.com/gokrazy/timestamps \
	github.com/stapelberg/rgb2r/cmd/grafana \
	github.com/stapelberg/rgb2r/cmd/prometheus \
	github.com/stapelberg/rgb2r/cmd/node_exporter \
	github.com/stapelberg/rgb2r/cmd/blackbox_exporter \
	github.com/stapelberg/rgb2r/cmd/ratelimit \
	github.com/stapelberg/rgb2r/cmd/tc \
	github.com/stapelberg/rgb2r/cmd/wg

image:
ifndef DIR
	@echo variable DIR unset
	false
endif
	GOARCH=amd64 gokr-packer \
		-gokrazy_pkgs=github.com/gokrazy/gokrazy/cmd/ntp,github.com/gokrazy/gokrazy/cmd/randomd \
		-kernel_package=github.com/rtr7/kernel \
		-firmware_package=github.com/rtr7/kernel \
		-overwrite_boot=${DIR}/boot.img \
		-overwrite_root=${DIR}/root.img \
		-overwrite_mbr=${DIR}/mbr.img \
		-serial_console=ttyS0,115200n8 \
		-hostname=rgb2router \
		${PKGS}
</code></pre>

<p>After preparing an <code>interfaces.json</code> configuration file and a
<a href="https://github.com/gokrazy/breakglass">breakglass</a> SSH hostkey, I used
<code>rtr7-recover</code> to net-install the image onto the apu2c4. For subsequent updates,
I used <code>rtr7-safe-update</code>.</p>

<p>The Go packages under <code>github.com/stapelberg/rgb2r</code> are wrappers which run
software I installed to the permanent partition mounted at <code>/perm</code>. See
<a href="https://gokrazy.org/prototyping.html">gokrazy: Prototyping</a> for more details.</p>

<h3 id="tunnel-setup">Tunnel setup</h3>

<p>Last year, we used a Foo-over-UDP tunnel after noticing that we didn’t get
enough bandwidth with OpenVPN. This year, after hearing much about it, we
successfully used <a href="https://www.wireguard.com/">WireGuard</a>.</p>

<p>I found WireGuard to be more performant than OpenVPN, and easier to set up than
either OpenVPN or Foo-over-UDP.</p>

<p>The one wrinkle is that its wire protocol is not yet frozen, and its kernel
module is not yet included in Linux.</p>

<h3 id="traffic-shaping">Traffic shaping</h3>

<p>With asymmetric internet connections, such as the 400/20 cable connection we’re
using, it’s necessary to shape traffic such that the upstream is never entirely
saturated, otherwise the TCP ACK packets won’t reach their destination in time
to saturate the downstream.</p>

<p>While the FritzBox might already provide traffic shaping, we wanted to
voluntarily restrict our upstream usage to leave some headroom for my parents.</p>

<pre><code>rgb2router# tc qdisc replace dev uplink0 root tbf \
  rate 16mbit \
  latency 50ms \
  burst 4000
</code></pre>

<p>The specified <code>latency</code> value is a best guess, and the <code>burst</code> value is derived
from the kernel internal timer frequency (<code>CONFIG_HZ</code>) (!), packet size and rate
as per
<a href="https://unix.stackexchange.com/questions/100785/bucket-size-in-tbf">https://unix.stackexchange.com/questions/100785/bucket-size-in-tbf</a>.</p>

<p>Tip: keep in mind to disable shaping temporarily when you’re doing bandwidth
tests ;-).</p>

<h3 id="statistics">Statistics</h3>

<ul>
<li><p>We peaked at 59 active DHCP leases, which is very similar to the “about 60”
last year.</p></li>

<li><p>DNS traffic peaked at about 25 queries/second, while mostly remaining at less
than 5 queries/second.</p></li>

<li><p>We were able to obtain peaks of nearly 200 Mbit/s of download traffic and
transferred over 200 GB of data, twice as much as last year.</p></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Looking for a new Raspberry Pi image maintainer]]></title>
    <link href="https://michael.stapelberg.de/posts/2018-06-03-raspi3-looking-for-maintainer/"/>
    <id>https://michael.stapelberg.de/posts/2018-06-03-raspi3-looking-for-maintainer/</id>
    <published>2018-06-03T08:43:00+02:00</published>
    <updated>2019-02-05T09:42:13+01:00</updated>
    <content type="html"><![CDATA[<p>
  <strong>This is taken care of: Gunnar Wolf has taken on maintenance of the Raspberry Pi image. Thank you!</strong>
</p>

<p>
  (Cross-posting this message I sent to pkg-raspi-maintainers for broader visibility.)
</p>

<p>
  I started building Raspberry Pi images because I thought there should be an easy, official way to install Debian on the Raspberry Pi.
</p>

<p>
  I still believe that, but I’m not actually using Debian on any of my Raspberry Pis anymore¹, so my personal motivation to do any work on the images is gone.
</p>

<p>
  On top of that, I realize that my commitments exceed my spare time capacity, so I need to get rid of responsibilities.
</p>

<p>
  Therefore, <strong>I’m looking for someone to take up maintainership of the Raspberry Pi images</strong>. Numerous people have reached out to me with thank you notes and questions, so I think the user interest is there. Also, I’ll be happy to answer any questions that you might have and that I can easily answer. Please reply here (or in private) if you’re interested.
</p>

<p>
  If I can’t find someone within the next 7 days, I’ll put up an announcement message in the raspi3-image-spec README, wiki page, and my blog posts, stating that the image is unmaintained and looking for a new maintainer.
</p>

<p>
  Thanks for your understanding,
</p>

<p>
  ① just in case you’re curious, I’m now running cross-compiled Go programs directly under a Linux kernel and minimal userland, see <a href="https://gokrazy.org/">https://gokrazy.org/</a>
</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Installing Dell’s Ubuntu image on an XPS 9360]]></title>
    <link href="https://michael.stapelberg.de/posts/2018-05-07-xps-13-9360-linux/"/>
    <id>https://michael.stapelberg.de/posts/2018-05-07-xps-13-9360-linux/</id>
    <published>2018-05-07T09:10:00+02:00</published>
    <updated>2018-05-07T09:20:01+02:00</updated>
    <content type="html"><![CDATA[

<p>Warning: if you don’t understand one of the steps, don’t blindly follow them,
but ask a friend for help instead! Be sure to have a known-working backup
before messing with your system.</p>

<h3 id="motivation">Motivation</h3>

<p>I recently got a Dell XPS 13 9360 (2017), which of course I would like to use
with Linux. I figured I’d give Dell’s Ubuntu version a try, as it is the closest
I can get to a supported Linux offering on a modern laptop.</p>

<p>Unfortunately, Dell doesn’t sell the XPS 9360 in its shop anymore (and I don’t
like its successor due to the lack of USB A ports), so I had to resort to buying
a version that comes with Windows.</p>

<p>You can obtain the recovery image
<code>dell-bto-xenial-dino2-mlk-A00-iso-20161021-0.iso</code> from
<a href="http://www.dell.com/support/home/us/en/19/Drivers/OSISO/W764">http://www.dell.com/support/home/us/en/19/Drivers/OSISO/W764</a>, provided you have
the system tag of an XPS 9360 that came with Linux — ask a friend if you
accidentally purchased the Windows version. Tip: the service tag is the BIOS
serial number, which is included in the output of
<a href="https://manpages.debian.org/stretch/lshw/lshw.1.en"><code>lshw(1)</code></a> and similar
tools.</p>

<h3 id="making-the-image-bootable">Making the image bootable</h3>

<p>I don’t understand why this image is not bootable by default. The device it was
generated for never had a CD/DVD drive, so what good is using an ISO 9660 image?</p>

<p>Anyway, to make the image bootable, I formatted a USB thumb drive with a FAT
file system and installed GRUB in such a way that it will loopback-boot into the
ISO image (this is option 2 from <a href="https://askubuntu.com/a/395880">https://askubuntu.com/a/395880</a>):</p>

<pre><code>grub-mkimage -o bootx64.efi -p /efi/boot -O x86_64-efi \
 fat iso9660 part_gpt part_msdos \
 normal boot linux configfile loopback chain \
 efifwsetup efi_gop efi_uga \
 ls search search_label search_fs_uuid search_fs_file \
 gfxterm gfxterm_background gfxterm_menu test all_video loadenv \
 exfat ext2 ntfs btrfs hfsplus udf
cat &gt;grub.cfg &lt;&lt;'EOT'
set timeout=3
set color_highlight=black/light-magenta

menuentry 'Ubuntu ISO' {
        set isofile=&quot;/efi/boot/dell-bto-xenial-dino2-mlk-A00-iso-20161021-0.iso&quot;
        loopback loop $isofile
        linux (loop)/casper/vmlinuz.efi boot=casper iso-scan/filename=$isofile noprompt noeject quiet splash persistent --
        initrd (loop)/casper/initrd.lz
}
EOT

sudo mkfs.vfat /dev/sdc
pmount /dev/sdc
mkdir -p /media/sdc/efi/boot
cp bootx64.efi *.iso grub.cfg /media/sdc/efi/boot
pumount sdc
</code></pre>

<h3 id="making-the-installer-work">Making the installer work</h3>

<p>To get the installer to work, I had to comment out the <code>self.genuine</code> checks in
<code>/usr/lib/ubiquity/plugins/dell-{bootstrap,recovery}.py</code>, then start <code>ubiquity</code>
from the terminal.</p>

<h3 id="switch-to-luks-full-disk-encryption">Switch to LUKS full-disk encryption</h3>

<p>Unfortunately, the recovery installation only offers you to encrypt your
homedir, whereas I would like to encrypt my entire disk. Here are the steps I
took to enable LUKS full-disk encryption.</p>

<p>First, I copied the root file system’s data to my backup storage. Pay attention
to copying the files as root, otherwise setuid and setgid bits might get lost.</p>

<pre><code># mount /dev/mapper/nvme0n1p3 /mnt/root
# rsync -aXx --relative --numeric-ids /mnt/root/ root@storage:xps/
# umount /mnt/root
</code></pre>

<p>Then, I created a new boot partition, encrypted the root partition and re-created the file system:</p>

<pre><code># cat &lt;&lt;'EOT' | sfdisk /dev/nvme0n1
label: gpt
label-id: C64A87D1-CA61-4BF2-81E6-0216EE6BC4C0
device: /dev/nvme0n1
unit: sectors
first-lba: 34
last-lba: 2000409230

/dev/nvme0n1p1 : start=          34, size=      488248, type=C12A7328-F81F-11D2-BA4B-00A0C93EC93B, name=&quot;EFI System Partition&quot;
/dev/nvme0n1p2 : start=      488282, size=     5380681, type=EBD0A0A2-B9E5-4433-87C0-68B6B72699C7, name=&quot;fat32&quot;
/dev/nvme0n1p3 : start=     5869568, size=     2097152, type=0FC63DAF-8483-4772-8E79-3D69D8477DE4
/dev/nvme0n1p4 : start=     7966720, size=  1992442511, type=0FC63DAF-8483-4772-8E79-3D69D8477DE4
EOT
# mkfs.ext2 /dev/nvme0n1p3
# cryptsetup luksFormat /dev/nvme0n1p4
# cryptsetup luksOpen /dev/nvme0n1p4 nvme0n1p3_crypt
# mkfs.ext4 /dev/mapper/nvme0n1p4_crypt
</code></pre>

<p>Next, I restored the data:</p>

<pre><code># mount /dev/mapper/nvme0n1p4_crypt /mnt/root
# mount /dev/nvme0n1p3 /mnt/root/boot
# mkdir /mnt/root/boot/efi
# mount /dev/nvme0n1p1 /mnt/root/boot/efi
# rsync -aXx --numeric-ids storage:xps/ /mnt/root
</code></pre>

<p>And finally, I fixed the boot partition:</p>

<pre><code># mount -o bind /dev /mnt/root/dev
# mount -t sysfs sysfs /mnt/root/sys
# mount -t proc proc /mnt/root/proc
# chroot /mnt/root /bin/bash

# apt install cryptsetup
# echo nvme0n1p4_crypt UUID=$(blkid -o value -s UUID /dev/nvme0n1p4) none luks,discard &gt; /etc/crypttab
# cat &gt;/etc/fstab &lt;&lt;EOT
UUID=$(blkid -o value -s UUID /dev/mapper/nvme0n1p4_crypt) / ext4 errors=remount-ro 0 1
UUID=$(blkid -o value -s UUID /dev/nvme0n1p3) /boot ext2 defaults 0 0
UUID=$(blkid -o value -s UUID /dev/nvme0n1p1) /boot/efi vfat umask=0077 0 1
EOT
# update-initramfs -u
# update-grub
# grub-install

# umount /mnt/root/{proc,sys,dev,boot/efi,boot,}
</code></pre>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[kinX: USB Hub]]></title>
    <link href="https://michael.stapelberg.de/posts/2018-04-17-kinx-usb-hub/"/>
    <id>https://michael.stapelberg.de/posts/2018-04-17-kinx-usb-hub/</id>
    <published>2018-04-17T17:49:00+02:00</published>
    <updated>2019-01-26T21:47:38+01:00</updated>
    <content type="html"><![CDATA[

<p>This post is part of a <a href="/posts/2018-04-17-kinx">series of posts about the kinX project</a>.</p>

<h3 id="motivation">Motivation</h3>

<p>The Kinesis Advantage comes with a built-in 2-port USB hub. That hub uses a
proprietary connector to interface with a
<a href="https://en.wikipedia.org/wiki/PS/2_port">PS/2</a> keyboard controller, so it
cannot be used with a USB keyboard controller. As the built-in hub is the
natural place to connect the Logitech unified receiver dongle, not being able to
use the hub is mildly annoying.</p>

<p>The kinX MK66F keyboard controller presently needs two USB cables: one connected
to the USBFS port to supply the PCB with power and receive firmware updates (via
the Teensy bootloader chip), and one connected to the USBHS port for the actual
keyboard device.</p>

<p>Lastly, even if the original built-in USB hub had internal ports (instead of a
PS/2 converter), it only supports USB 1.1, nullifying any latency improvements.</p>

<p>Hence, I decided to build a drop-in replacement USB 2.0 hub with 2 external USB
ports and 2 internal USB ports, using the same proprietary connector as the
original, so that the original keyboard USB cable could be re-used.</p>

<h3 id="design-phase">Design phase</h3>

<p>Unfortunately, I could not find an open hardware USB 2.0 hub design on the
internet, so I started researching various USB hub chips. I quickly discarded
the idea of using USB 3 due to its much stricter requirements.</p>

<p>In the end, I decided to go with the Cypress HX2VL series because of their
superior documentation: I found a detailed data sheet, an evaluation board, the
associated schematics, design checklist/guidelines, and even the evaluation
board’s bill of materials.</p>

<p>This is what the finished build of my design looks like:</p>

<p><img src="/Bilder/kinx-hub.jpg" width="100%"></p>

<h3 id="power">Power</h3>

<p>After completing my first build, I tested a few USB devices with my hub. The
Logitech unified receiver dongle and the
<a href="https://www.yubico.com/start/">YubiKey</a> worked fine. However, my external hard
drive and my USB memory stick did not work. In the syslog, I would see:</p>

<pre><code>kernel: usb 1-14.4.4: rejected 1 configuration due to insufficient available bus power
</code></pre>

<p>This is because the USB specification limits bus-powered hubs to 100mA per
port. While high power usage does not come as a surprise for the external hard
disk, it turns out that even my USB memory stick requires 200mA. This was a
surprise, because that stick works on other, commercial bus-powered USB hubs.</p>

<p>A closer look reveals that all 3 commercial USB hubs I have tested claim to be
self-powered (i.e. using an external power supply), even though they are
not. This way, the kernel’s power limitation is circumvented, and up to 500mA
can be used per port. In practice, the host port only supplies 500mA, so the
user must be careful not to plug in devices which require more than 500mA in
aggregate.</p>

<p>I changed the SELFPWR configuration pin to have my hub claim it was
self-powered, too, and that made all USB devices I tested work fine.</p>

<h3 id="eeprom-programming">EEPROM programming</h3>

<p>When debugging the power issue, I originally thought the Maximum Power setting
in the hub’s USB device descriptor needed to be raised. This turned out to not
be correct: the Maximum Power refers to the power which the hub uses for its own
circuitry, not the power it passes through to connected devices.</p>

<p>Nevertheless, it’s a nice touch to modify the device descriptor to put in a
custom vendor name, product name and serial number: that way, the device shows
up with a recognizable name in your syslog or
<a href="https://manpages.debian.org/stretch/usbutils/lsusb.8"><code>lsusb(8)</code></a> output, and
udev rules can be used to apply settings based on the serial number.</p>

<p>To modify the device descriptor, an <a href="https://en.wikipedia.org/wiki/EEPROM">EEPROM (electrically erasable programmable
read-only memory)</a> needs to be added to
the design, from which the HX2VL will read configuration.</p>

<p>The HX2VL allows field-programming of the connected EEPROM, i.e. writing to it
via the USB hub chip. I found the Windows-only tool hard to set up on a modern
Windows installation, so I wondered whether I could build a simpler to use tool.</p>

<p>Under the covers, the tool merely sends commands with the vendor-specific
request code 14 via USB, specifying an index of the two-byte word to
read/write. This can be replicated in a few lines of Go:</p>

<pre><code>dev, _ := usb.OpenDeviceWithVIDPID(0x04b4, 0x6570)
eepromRequest := 14
wIndex := 0 // [0, 63] for 128 bytes of EEPROM
dev.Control(gousb.RequestTypeVendor|0x80, 
  eepromRequest, 0, wIndex, make([]byte, 2))
</code></pre>

<p>The EEPROM contents are well-described in the <a href="http://www.cypress.com/file/114101/download">HX2VL data
sheet</a>, so the rest is easy.</p>

<p>See <a href="https://github.com/kinx-project/mk66f-blaster">https://github.com/kinx-project/mk66f-blaster</a> for the tool.</p>

<h3 id="lessons-learnt">Lessons learnt</h3>

<ul>
<li><p>If possible, design the PCB in such a way that components you think you don’t
need (e.g. the EEPROM) can optionally be soldered on. This would have saved me
a PCB design/fabrication cycle.</p></li>

<li><p>Get the evaluation board to figure out the configuration you need
(e.g. self-powered vs. bus-powered).</p></li>
</ul>

<h3 id="next-up">Next up</h3>

<p>The <a href="/posts/2018-04-17-kinx-latency-measurement/">last post introduces the processing latency measurement firmware for the
FRDM-K66F development board</a> and
draws a conclusion.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[kinX: keyboard controller with &lt;0.225ms input latency]]></title>
    <link href="https://michael.stapelberg.de/posts/2018-04-17-kinx-keyboard-controller/"/>
    <id>https://michael.stapelberg.de/posts/2018-04-17-kinx-keyboard-controller/</id>
    <published>2018-04-17T17:49:00+02:00</published>
    <updated>2019-01-26T21:47:38+01:00</updated>
    <content type="html"><![CDATA[

<p>This post is part of a <a href="/posts/2018-04-17-kinx">series of posts about the kinX project</a>.</p>

<h3 id="background">Background</h3>

<p>10 years ago I got a Kinesis Advantage keyboard. I wrote about the experience of
learning to touch-type using the ergonomic <a href="https://neo-layout.org/">NEO layout</a>
in my (German) post <a href="/posts/2009-01-01-neo_kinesis/">“Neo-Layout auf einer
Kinesis-Tastatur”</a>.</p>

<p>The Kinesis Advantage is still the best keyboard I’ve ever used, and I use one
every day, both at the office and at home.</p>

<p>I had two reasons to start modifying the keyboard:</p>

<ol>
<li><p>I prefer Cherry MX blue key switches over the Cherry MX brown key switches
the Kinesis comes with. Nowadays, you can get a Kinesis with Cherry MX red
key switches, which felt okay in a quick test.</p></li>

<li><p>The original keyboard controller has (had?) a bug where modifier keys such as
Shift would get stuck at least once a week: you would press Shift, press A,
release A, release Shift, press A and see AA instead of Aa.</p></li>
</ol>

<p>I solved issue ① with the help of the excellent Kinesis technical support, who
sold me unpopulated PCBs so that I could solder on my own key switches.</p>

<p>Issue ② was what lead to my first own keyboard controller build, which I
documented in <a href="/posts/2013-03-21-kinesis_custom_controller/">“Hacking your own Kinesis keyboard
controller”</a> (2013).</p>

<p>Then, the topic of input latency popped into my filter bubble, with excellent
 posts such as <a href="https://pavelfatin.com/typing-with-pleasure/">Pavel Fatin’s “Typing with
pleasure”</a>. I started wondering
what input latency I was facing, and whether/how I could reduce it.</p>

<p>Given that I was using a custom keyboard controller, it was up to me to answer
that question. After trying to understand and modify the firmware I had been
using for the last 4 years, I realized that I first needed to learn much more
about how keyboards work.</p>

<p>I firmly believe that creating a good environment is vital for development,
especially for intrinsically-motivated side projects like this one. Hence, I set
the project aside until a colleague gifted me his old Kinesis which had
intermittent issues. I removed the electronics and started using that keyboard
as my development keyboard.</p>

<h3 id="sources-of-input-latency">Sources of input latency</h3>

<p>A keyboard controller has 3 major tasks:</p>

<ul>
<li><p><strong>matrix scan</strong>: to avoid physically connecting every single key switch
directly to a microcontroller (requiring a large number of GPIO pins), most
keyboards use a matrix. See <a href="http://blog.komar.be/how-to-make-a-keyboard-the-matrix/">“How to make a keyboard — the
matrix”</a> for a good
explanation.</p></li>

<li><p><strong>debouncing</strong>: when pressing a key switch, it doesn’t cleanly change from a
low voltage level to a high voltage level (or vice-versa). Instead, it
bounces: the voltage level rapidly oscillates until it eventually reaches a
stable steady state. Because one key press shouldn’t result in a whole bunch
of characters, keyboard controllers need to debounce the key press.</p></li>

<li><p><strong>USB</strong>: nowadays, keyboards use USB (for example to be compatible with
laptops, which generally don’t have PS/2 ports), so the keyboard’s state needs
to be communicated to the computer via USB.</p></li>
</ul>

<p>Here’s an illustration of the timing of a key press being handled by a naive
keyboard controller implementation:</p>

<p><img src="/Bilder/kinx-input-latency-sources.svg"></p>

<p>In the worst case, a key press happens just after a keyboard matrix scan. The
first source of latency is the time it takes until the next keyboard matrix scan
happens.</p>

<p>Depending on the implementation, the key press now sits in a data structure,
waiting for the debounce time to pass.</p>

<p>Finally, once the key press was successfully debounced, the device must wait
until the USB host polls it before it can send the HID report.</p>

<p>Unless the matrix scan interval is coupled to the USB poll interval, the delays
are additive, and the debounce time is usually constant: in the best case, a key
press happens just before a matrix scan (0ms) and gets debounced (say, 5ms) just
before a USB poll (0ms).</p>

<h3 id="teensy-3-6-controller-for-learning">Teensy 3.6 controller (for learning)</h3>

<p>My old keyboard controller used the
<a href="https://www.pjrc.com/teensy/index.html">Teensy++</a>, which is fairly dated at
this point. I decided a good start of the project would be to upgrade to the
current Teensy 3.6, cleaning up the schematics on the way.</p>

<p><img src="/Bilder/kinx-teensy36.jpg" width="100%"></p>

<p>To ensure I understand all involved parts, I implemented a bare-metal firmware
almost from scratch: I cobbled together the required startup code, USB stack
and, most importantly, key matrix scanning code.</p>

<p>In my firmware, the Teensy 3.6 runs at 180 MHz (compared to the Teensy++’s 16
MHz) and scans the keyboard matrix in a busy loop (as opposed to on USB
poll). Measurements confirmed a matrix scan time of only 100μs (0.1ms).</p>

<p>I implemented debouncing the way it is described in <a href="https://summivox.wordpress.com/2016/06/03/keyboard-matrix-scanning-and-debouncing/">Yin Zhong’s “Keyboard
Matrix Scanning and
Debouncing”</a>:
by registering a key press/release on the rising/falling edge and applying the
debounce time afterwards, effectively eliminating debounce latency.</p>

<p>Note that while the Cherry MX datasheet specifies a debounce time of 5ms, I
found it necessary to increase the time to 10ms to prevent bouncing in some of
my key switches, which are already a few years old.</p>

<p>I set the USB device descriptor’s poll interval to 1, meaning poll every 1 USB
micro frame, which is 1ms long with USB 1.x (Full Speed).</p>

<p>This leaves us at an input latency within [0ms, 1.1ms]:</p>

<ul>
<li>≤ 0.1ms scan latency</li>
<li>0ms debounce latency</li>
<li>≤ 1ms USB poll latency</li>
</ul>

<p>Can we reduce the input latency even further? The biggest factor is the USB poll
interval.</p>

<h3 id="usb-high-speed">USB High Speed</h3>

<p>With USB 2.0 High Speed, the micro frame duration is reduced to 125μs
(0.125ms). The NXP MK66F micro controller in the Teensy 3.6 has two USB ports:</p>

<ol>
<li>the Full Speed-only USBFS port, which is used by the Teensy 3.6</li>
<li>the High Speed-capable USBHS port, which the Teensy optionally uses for host
mode, with experimental software support (at the time of writing)</li>
</ol>

<p><img src="/Bilder/kinx-usbhs-breakout.jpg" width="100%"></p>

<p>While the software support was a road block which could conceivably be solved, I
also faced a mechanical problem: the available space in the Kinesis keyboard and
the position of the USB High Speed port pins on the Teensy 3.6 unfortunately
prevented installing any sort of breakout board to actually use the port.</p>

<p>I decided to move from the Teensy 3.6 to my own design with the same
microcontroller.</p>

<h3 id="mk66f-keyboard-controller">MK66F keyboard controller</h3>

<p><img src="/Bilder/kinx-mk66f.jpg" width="100%"></p>

<p>To make development pleasant, I connected a USB-to-serial adapter (to UART0) and
a “rebootor” (to PROGHEAD): another Teensy with a special firmware to trigger
programming mode. This way, I could set my editor’s <code>compile-command</code> to <code>make
&amp;&amp; teensy_loader_cli -r …</code>, compiling the code, uploading and booting into the
resulting firmware with a single keyboard shortcut.</p>

<p>I based the firmware for this controller on NXP’s SDK examples, to ensure I get
a well-tested and maintained USB stack for the USBHS port. I did some
measurements to confirm the stack does not add measurable extra latency, so I
did not see any value in me maintaining a custom USB stack.</p>

<p>The firmware can be found at <a href="https://github.com/kinx-project/mk66f-fw">https://github.com/kinx-project/mk66f-fw</a></p>

<p>The hardware can be found at <a href="https://github.com/kinx-project/mk66f-hw">https://github.com/kinx-project/mk66f-hw</a></p>

<p>Using USB 2.0 High Speed leaves us at an input latency within [0ms, 0.225ms]:</p>

<ul>
<li>≤ 0.1ms scan latency</li>
<li>0ms debounce latency</li>
<li>≤ 0.125ms USB poll latency</li>
</ul>

<h3 id="lessons-learnt">Lessons learnt</h3>

<ul>
<li><p>In the future, I will base custom designs on the vendor’s development board
(instead of on the Teensy). This way, the vendor-provided code could be used
without any modifications.</p></li>

<li><p>While the Teensy bootloader means getting started with the microcontroller
just requires a USB port, using a JTAG connector for development would be more
powerful: not only does it replace the combination of Teensy bootloader,
serial and rebootor, but it also supports debugging with gdb.</p></li>
</ul>

<h3 id="next-up">Next up</h3>

<p>The <a href="/posts/2018-04-17-kinx-usb-hub/">second post motivates and describes building a drop-in replacement USB
hub</a> for the Kinesis Advantage keyboard.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[kinX: latency measurement]]></title>
    <link href="https://michael.stapelberg.de/posts/2018-04-17-kinx-latency-measurement/"/>
    <id>https://michael.stapelberg.de/posts/2018-04-17-kinx-latency-measurement/</id>
    <published>2018-04-17T17:49:00+02:00</published>
    <updated>2019-01-26T21:47:38+01:00</updated>
    <content type="html"><![CDATA[

<p>This post is part of a <a href="/posts/2018-04-17-kinx">series of posts about the kinX project</a>.</p>

<h3 id="latency-measurement">Latency measurement</h3>

<p>End-to-end latency consists of 3 parts:</p>

<ol>
<li>input latency (keyboard)</li>
<li>processing latency (computer)</li>
<li>output latency (monitor)</li>
</ol>

<p>During the development of the kinX keyboard controller, I realized that
measuring processing latency was quite simple with my hardware: I could start a
timer when sending a key press HID report to the computer and measure the
elapsed time when I would receive a reply from the computer.</p>

<p>The key to send is the Caps Lock key, because unlike other keys it results in a
reply: a HID report telling the keyboard to turn the Caps Lock LED on.</p>

<p><img src="/Bilder/kinx-latency-measurement-device.svg"></p>

<h3 id="measurement-device">Measurement device</h3>

<p>To make this measurement technique accessible to as many people as possible, I
decided to pull it out of my kinX keyboard controller and instead build it using
the FRDM-K66F evaluation board, which uses the same microcontroller.</p>

<p>The FRDM-K66F can be bought for about 60 USD at big electronics shops, e.g. Digi-Key.</p>

<p>Find the firmware at <a href="https://github.com/kinx-project/measure-fw">https://github.com/kinx-project/measure-fw</a></p>

<h3 id="baseline">Baseline</h3>

<p>To determine the lowest processing latency one can possibly get for userspace
applications on a Linux system, I wrote a small program which uses Linux’s evdev
API to receive key presses and react to a Caps Lock keypress as quickly as it
can by turning the Caps Lock LED on.</p>

<p>Find the program at <a href="https://github.com/kinx-project/measure-evdev">https://github.com/kinx-project/measure-evdev</a></p>

<p>The following layers are exercised when measuring this program:</p>

<ul>
<li>USB host controller</li>
<li>Linux kernel (USB and input subsystems)</li>
<li>input event API (evdev)</li>
</ul>

<p>Notably, graphical interfaces such as X11 or Wayland are excluded.</p>

<p>The measurements can be verified using Wireshark’s usbmon capturing, which
provides a view of the USB bus from the computer’s perspective, excluding USB
poll latency and USB transaction time.</p>

<p>Using Ubuntu 17.10, I measured a processing latency of 152 μs on average.</p>

<h3 id="emacs">Emacs</h3>

<p>Now let’s see whether my current editor of choice adds significant latency.</p>

<p>Using a few lines of Emacs Lisp, I instructed Emacs to turn on the Caps Lock LED
whenever a key is inserted into the current buffer. In combination with
remapping the Caps Lock key to any other key (e.g. “a”), this allows us to
measure Emacs’s processing latency.</p>

<p>On the same Ubuntu 17.10 installation used above, Emacs 25.2.2 adds on average
278 μs to the baseline processing latency.</p>

<p>Find the code at <a href="https://github.com/kinx-project/measure-emacs">https://github.com/kinx-project/measure-emacs</a></p>

<h3 id="end-to-end-latency">End-to-end latency</h3>

<p>With the kinX keyboard controller, we can achieve the following end-to-end latency:</p>

<table>
<thead>
<tr>
<th>contributor</th>
<th>latency</th>
</tr>
</thead>

<tbody>
<tr>
<td>Matrix scan</td>
<td>≈ 100 μs</td>
</tr>

<tr>
<td>USB poll</td>
<td>≈ 125 μs</td>
</tr>

<tr>
<td>Linux</td>
<td>≈ 152 μs</td>
</tr>

<tr>
<td>Emacs</td>
<td>≈ 278 μs</td>
</tr>
</tbody>
</table>

<p><br>This sums up to ≈ 655 μs on average. On top of that, we have output latency
within [0, 16ms] due to the 60 Hz refresh rate of our monitors.</p>

<p>Note that using a compositor adds one frame of output latency.</p>

<h3 id="input-latency-perception">Input latency perception</h3>

<p>A natural question to ask is how well humans can perceive input latency. After
all, keyboards have been manufactured for many years, and if input latency was
really that important, surely manufacturers would have picked up on this fact by
now?</p>

<p>I ran a little unscientific experiment in the hope to further my understanding
of this question at the most recent Chaos Communication Congress in Leipzig.</p>

<p>In the experiment, I let 17 people play a game on a specially prepared
keyboard. In each round, the game reconfigures the keyboard to either have
additional input latency or not, decided at random. The player can then type a
few keys and make a decision. If the player can correctly indicate whether
additional input latency was present in more than 50% of the cases, the player
is said to be able to distinguish latency at that level. On each level, the game
decreases the additional input latency: it starts with 100ms, then 75ms, then
50ms, etc.</p>

<p>The most sensitive player reliably recognized an additional 15ms of input
latency.</p>

<p>Some players could not distinguish 75ms of additional input latency.</p>

<p>Every player could distinguish 100ms of additional input latency.</p>

<p>My take-away is that many people cannot perceive slight differences in input
latency at all, explaining why keyboard manufacturers don’t optimize for low
latency.</p>

<p>Reducing input latency still seems worthwhile to me: even if the reduction
happens under the threshold at which you can perceive differences in input
latency, it buys you more leeway in the entire stack. In other words, you might
now be able to turn on an expensive editor feature which previously slowed down
typing too much.</p>

<h3 id="conclusion">Conclusion</h3>

<p>When I started looking into input latency, my keyboard had dozens of
milliseconds of latency. I found an easy win in the old firmware, then hit a
wall, started the kinX project and eventually ended up with a keyboard with just
0.225ms input latency.</p>

<p>Even if I had not reduced the input latency of my keyboard at all, I feel that
this project was a valuable learning experience: I now know a lot more about PCB
design, ARM microcontrollers, USB, HID, etc.</p>

<p>Typing on a self-built keyboard feels good: be it because of the warm fuzzy
feeling of enjoying the fruits of your labor, or whether the input latency
indeed is lower, I’m happy with the result either way.</p>

<p>Lastly, I can now decidedly claim that the processing latency of modern
computers is perfectly fine (remember our 152 μs + 278 μs measurement for
Linux + Emacs), and as long as you pick decent peripherals, your end-to-end
latency will be fine, too.</p>

<h3 id="what-s-next">What’s next?</h3>

<p>By far the biggest factor in the end-to-end latency is the monitor’s refresh
rate, so getting a monitor with a high refresh rate and no additional processing
latency would be the next step in reducing the end-to-end latency.</p>

<p>As far as the keyboard goes, the matrix scan could be eliminated by wiring up
each individual key to a microcontroller with enough GPIO pins. The USB poll
delay could be eliminated by switching to USB 3, but I don’t know of any
microcontrollers which have USB 3 built-in yet. Both of these improvements are
likely not worth the effort.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[kinX: overview]]></title>
    <link href="https://michael.stapelberg.de/posts/2018-04-17-kinx/"/>
    <id>https://michael.stapelberg.de/posts/2018-04-17-kinx/</id>
    <published>2018-04-17T17:49:00+02:00</published>
    <updated>2019-01-26T21:47:38+01:00</updated>
    <content type="html"><![CDATA[<p>The kinX project is described in a series of blog posts:</p>

<ul>
<li><p>While not strictly a part of this series, <a href="/posts/2013-03-21-kinesis_custom_controller/">“Hacking your own Kinesis keyboard
controller”</a> describes the first
controller I built in 2013 (maybe interesting for context).</p></li>

<li><p>The <a href="/posts/2018-04-17-kinx-keyboard-controller/">first post introduces the kinX, a keyboard
controller</a> with merely 0.2ms of
input latency (including USB).</p></li>

<li><p>The <a href="/posts/2018-04-17-kinx-usb-hub/">second post motivates and describes building a drop-in replacement USB
hub</a> for the Kinesis Advantage keyboard.</p></li>

<li><p>The <a href="/posts/2018-04-17-kinx-latency-measurement/">last post introduces the processing latency measurement firmware for the
FRDM-K66F development board</a> and
draws a conclusion.</p></li>
</ul>

<p>You can find the project’s artifacts at <a href="https://github.com/kinx-project">https://github.com/kinx-project</a>.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[sbuild-debian-developer-setup(1)]]></title>
    <link href="https://michael.stapelberg.de/posts/2018-03-19-sbuild-debian-developer-setup/"/>
    <id>https://michael.stapelberg.de/posts/2018-03-19-sbuild-debian-developer-setup/</id>
    <published>2018-03-19T08:00:00+01:00</published>
    <updated>2019-02-04T19:08:45+01:00</updated>
    <content type="html"><![CDATA[<p>
  I have heard a number of times that sbuild is too hard to get started with,
  and hence people don’t use it.
</p>

<p>
  To reduce hurdles from using/contributing to Debian, I wanted to make sbuild
  easier to set up.
</p>

<p>
  sbuild ≥ 0.74.0 provides a Debian package
  called <a href="https://packages.debian.org/sid/sbuild-debian-developer-setup">sbuild-debian-developer-setup</a>. Once
  installed, run
  the <a href="https://manpages.debian.org/unstable/sbuild/sbuild-debian-developer-setup.1">sbuild-debian-developer-setup(1)</a>
  command to create a chroot suitable for building packages for Debian unstable.
</p>

<p>
  On a system without any sbuild/schroot bits installed, a transcript of the
  full setup looks like this:
</p>

<pre>
% sudo apt install -t unstable sbuild-debian-developer-setup
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following additional packages will be installed:
  libsbuild-perl sbuild schroot
Suggested packages:
  deborphan btrfs-tools aufs-tools | unionfs-fuse qemu-user-static
Recommended packages:
  exim4 | mail-transport-agent autopkgtest
The following NEW packages will be installed:
  libsbuild-perl sbuild sbuild-debian-developer-setup schroot
0 upgraded, 4 newly installed, 0 to remove and 1454 not upgraded.
Need to get 1.106 kB of archives.
After this operation, 3.556 kB of additional disk space will be used.
Do you want to continue? [Y/n]
Get:1 http://localhost:3142/deb.debian.org/debian unstable/main amd64 libsbuild-perl all 0.74.0-1 [129 kB]
Get:2 http://localhost:3142/deb.debian.org/debian unstable/main amd64 sbuild all 0.74.0-1 [142 kB]
Get:3 http://localhost:3142/deb.debian.org/debian testing/main amd64 schroot amd64 1.6.10-4 [772 kB]
Get:4 http://localhost:3142/deb.debian.org/debian unstable/main amd64 sbuild-debian-developer-setup all 0.74.0-1 [62,6 kB]
Fetched 1.106 kB in 0s (5.036 kB/s)
Selecting previously unselected package libsbuild-perl.
(Reading database ... 276684 files and directories currently installed.)
Preparing to unpack .../libsbuild-perl_0.74.0-1_all.deb ...
Unpacking libsbuild-perl (0.74.0-1) ...
Selecting previously unselected package sbuild.
Preparing to unpack .../sbuild_0.74.0-1_all.deb ...
Unpacking sbuild (0.74.0-1) ...
Selecting previously unselected package schroot.
Preparing to unpack .../schroot_1.6.10-4_amd64.deb ...
Unpacking schroot (1.6.10-4) ...
Selecting previously unselected package sbuild-debian-developer-setup.
Preparing to unpack .../sbuild-debian-developer-setup_0.74.0-1_all.deb ...
Unpacking sbuild-debian-developer-setup (0.74.0-1) ...
Processing triggers for systemd (236-1) ...
Setting up schroot (1.6.10-4) ...
Created symlink /etc/systemd/system/multi-user.target.wants/schroot.service → /lib/systemd/system/schroot.service.
Setting up libsbuild-perl (0.74.0-1) ...
Processing triggers for man-db (2.7.6.1-2) ...
Setting up sbuild (0.74.0-1) ...
Setting up sbuild-debian-developer-setup (0.74.0-1) ...
Processing triggers for systemd (236-1) ...

% sudo sbuild-debian-developer-setup
The user `michael' is already a member of `sbuild'.
I: SUITE: unstable
I: TARGET: /srv/chroot/unstable-amd64-sbuild
I: MIRROR: http://localhost:3142/deb.debian.org/debian
I: Running debootstrap --arch=amd64 --variant=buildd --verbose --include=fakeroot,build-essential,eatmydata --components=main --resolve-deps unstable /srv/chroot/unstable-amd64-sbuild http://localhost:3142/deb.debian.org/debian
I: Retrieving InRelease 
I: Checking Release signature
I: Valid Release signature (key id 126C0D24BD8A2942CC7DF8AC7638D0442B90D010)
I: Retrieving Packages 
I: Validating Packages 
I: Found packages in base already in required: apt 
I: Resolving dependencies of required packages...
[…]
I: Successfully set up unstable chroot.
I: Run "sbuild-adduser" to add new sbuild users.
ln -s /usr/share/doc/sbuild/examples/sbuild-update-all /etc/cron.daily/sbuild-debian-developer-setup-update-all
Now run `newgrp sbuild', or log out and log in again.

% newgrp sbuild

% sbuild -d unstable hello
sbuild (Debian sbuild) 0.74.0 (14 Mar 2018) on x1

+==============================================================================+
| hello (amd64)                                Mon, 19 Mar 2018 07:46:14 +0000 |
+==============================================================================+

Package: hello
Distribution: unstable
Machine Architecture: amd64
Host Architecture: amd64
Build Architecture: amd64
Build Type: binary
[…]
</pre>

<p>
  I hope you’ll find this useful.
</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[cpu(1) with Linux]]></title>
    <link href="https://michael.stapelberg.de/posts/2018-03-13-cpu/"/>
    <id>https://michael.stapelberg.de/posts/2018-03-13-cpu/</id>
    <published>2018-03-13T09:35:00+01:00</published>
    <updated>2018-06-23T15:07:33+02:00</updated>
    <content type="html"><![CDATA[

<h3 id="motivation">motivation</h3>

<p>To run the tests of my i3 Go package, I use the following command:</p>

<pre><code>go test -v go.i3wm.org/...
</code></pre>

<p>To run the tests of my i3 Go package on a different architecture, the only thing
I should need to change is to declare the architecture by setting
<code>GOARCH=arm64</code>:</p>

<pre><code>GOARCH=arm64 go test -v go.i3wm.org/...
</code></pre>

<p>“Easy!”, I hear you exclaim: “Just <code>apt install qemu</code>, and you can transparently
emulate architectures”. But what if I want to run my tests on a native machine,
such as the various <a href="https://db.debian.org/machines.cgi?sortby=purpose&amp;sortorder=dsc">Debian porter
boxes</a>? Down
the rabbit hole we go…</p>

<h3 id="cpu-1">cpu(1)</h3>

<p>On Plan 9, the <a href="http://man.cat-v.org/plan_9/1/cpu">cpu(1)</a> command allows
transparently using the CPU of dedicated compute servers. This has fascinated me
for a long time, so I tried to replicate the functionality in Linux.</p>

<h3 id="reverse-sshfs">reverse sshfs</h3>

<p>One of the key insights this project is built on is that
<a href="https://manpages.debian.org/stretch/sshfs/sshfs.1"><code>sshfs(1)</code></a> can be used over
an already-authenticated channel, so you don’t need to do awkward reverse
port-forwardings or even allow the remote machine SSH access to your local
machine.</p>

<p>I learnt this trick from the 2014 <a href="https://blog.dhampir.no/content/reverse-sshfs-mounts-fs-push">boltblog post “Reverse SSHFS mounts (fs
push)”</a>.</p>

<p>The post uses <a href="https://manpages.debian.org/stretch/vde2/dpipe.1"><code>dpipe(1)</code></a>’s
bidirectional wiring of stdin/stdout (as opposed to a unidirectional wiring like
in UNIX pipes).</p>

<p>Instead of clumsily running <code>dpipe</code> in a separate window, I encapsulated the
necessary steps in a little Go program I call <code>cpu</code>. The reverse sshfs principle
looks like this in Go:</p>

<pre><code>sftp := exec.Command(&quot;/usr/lib/openssh/sftp-server&quot;)
stdin, _ := sftp.StdinPipe()
stdout, _ := sftp.StdoutPipe()
session.Stdin = stdout
session.Stdout = stdin
sftp.Stderr = os.Stderr
session.Stderr = os.Stderr
const (
	host = &quot;&quot;
	src  = &quot;/&quot;
	mnt  = &quot;/mnt&quot;
)
session.Start(fmt.Sprintf(&quot;sshfs %s:%s %s -o slave&quot;, host, src, mnt))
sftp.Start()
</code></pre>

<p>Here’s how the tool looks in action:</p>

<script src="https://asciinema.org/a/Q1BWLcdtIMOE5SCHOzu1eqcOE.js" id="asciicast-Q1BWLcdtIMOE5SCHOzu1eqcOE" async></script>

<h3 id="binfmt-misc">binfmt_misc</h3>

<p>Now that we have a tool which will make our local file system available on the
remote machine, let’s integrate it into our <code>go test</code> invocation.</p>

<p>While we don’t want to modify the <code>go</code> tool, we can easily teach our kernel how
to run aarch64 ELF binaries using
<a href="https://www.kernel.org/doc/html/v4.14/admin-guide/binfmt-misc.html">binfmt_misc</a>.</p>

<p>I modified the existing <code>/var/lib/binfmts/qemu-aarch64</code>’s interpreter field to
point to <code>/home/michael/go/bin/porterbox-aarch64</code>, followed by <code>update-binfmts
--enable qemu-aarch64</code> to have the kernel pick up the changes.</p>

<p><code>porterbox-aarch64</code> is a wrapper invoking <code>cpu</code> like so:</p>

<pre><code>cpu \
  -host=rpi3 \
  unshare \
    --user \
    --map-root-user \
    --mount-proc \
    --pid \
    --fork \
    /bindmount.sh \
      \$PWD \
      $PWD \
      $@
</code></pre>

<p>Because it’s subtle:</p>

<ul>
<li><code>\$PWD</code> refers to the directory in which the reverse sshfs was mounted by <code>cpu</code>.</li>
<li><code>$PWD</code> refers to the working directory in which <code>porterbox-aarch64</code> was called.</li>
<li><code>$@</code> refers to the original command with which <code>porterbox-aarch64</code> was called.</li>
</ul>

<h3 id="bindmount">bindmount</h3>

<p>bindmount is a small shell script preparing the bind mounts:</p>

<pre><code>#!/bin/sh

set -e

remote=&quot;$1&quot;
shift
wd=&quot;$1&quot;
shift

# Ensure the executable (usually within /tmp) is available:
exedir=$(dirname &quot;$1&quot;)
mkdir -p &quot;$exedir&quot;
mount --rbind &quot;$remote$exedir&quot; &quot;$exedir&quot;

# Ensure /home is available:
mount --rbind &quot;$remote/home&quot; /home

cd &quot;$wd&quot;
&quot;$@&quot;
</code></pre>

<h3 id="demo">demo</h3>

<p>This is what all of the above looks like in action:</p>

<script src="https://asciinema.org/a/Mjb66iHIbBfGuK5lEMnLt0UzS.js" id="asciicast-Mjb66iHIbBfGuK5lEMnLt0UzS" async></script>

<h3 id="layers">layers</h3>

<p>Putting all of the above puzzle pieces together, we end up with the following
picture:</p>

<pre><code>go test
├ compile test program for GOARCH=arm64
└ exec test program (on host)
  └ binfmt_misc
    └ run porterbox-aarch64
      └ cpu -host=rpi3
        ├ reverse sshfs
        └ bindmount.sh
          └ unshare --user
            ├ bind /home, /tmp
            └ run test program (on target)
</code></pre>

<h3 id="requirements">requirements</h3>

<p>On the remote host, the following requirements need to be fulfilled:</p>

<ul>
<li><code>apt install sshfs</code>, which also activates the FUSE kernel module</li>
<li><code>sysctl -w kernel.unprivileged_userns_clone=1</code></li>
</ul>

<p>If the tests require any additional dependencies (the tests in question require
<code>Xvfb</code> and <code>i3</code>), those need to be installed as well.</p>

<p>On Debian porter boxes, you can install the dependencies in an <a href="https://dsa.debian.org/doc/schroot/"><code>schroot</code>
session</a>. Note that I wasn’t able to test
this yet, as porter boxes lacked all requirements at the time of writing.</p>

<p>Unfortunately, <a href="https://wiki.debian.org/Multiarch">Debian’s Multi-Arch</a> does not
yet include binaries. Otherwise, one might use it to help out with the
dependencies: one could overlay the local <code>/usr/bin/aarch64-linux-gnu/</code> on the
remote <code>/usr/bin</code>.</p>

<h3 id="conclusion">conclusion</h3>

<p>On first glance, this approach works as expected. Time will tell whether it’s
useful in practice or just an interesting one-off exploration.</p>

<p>From a design perspective, there are a few open questions:</p>

<ul>
<li>Making available only <code>/home</code> might not be sufficient. But making available
<code>/</code> doesn’t work because <code>sshfs</code> does not support device nodes such as
<code>/dev/null</code>.</li>
<li>Is there a way to implement this without unprivileged user namespaces (which
are disabled by default on Linux)? Essentially, I think I’m asking for <a href="https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs#Union_directories_and_namespaces">Plan
9’s union directories and
namespaces</a>.</li>
<li>In similar spirit, can binfmt_misc be used per-process?</li>
</ul>

<p>Regardless, if this setup stands the test of time, I’ll polish and publish the
tools.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[dput usability changes]]></title>
    <link href="https://michael.stapelberg.de/posts/2018-03-10-dput-usability/"/>
    <id>https://michael.stapelberg.de/posts/2018-03-10-dput-usability/</id>
    <published>2018-03-10T10:00:00+01:00</published>
    <updated>2019-02-04T19:08:45+01:00</updated>
    <content type="html"><![CDATA[<p>
  dput-ng ≥ 1.16 contains two usability changes which make uploading easier:
</p>

<ol>
  <li>
    When no arguments are specified, dput-ng auto-selects the most recent .changes file (with confirmation).
  </li>
  <li>
    Instead of erroring out when detecting an unsigned .changes file, <a href="https://manpages.debian.org/stretch/devscripts/debsign.1">debsign(1)</a> is invoked to sign the .changes file before proceeding.
  </li>
</ol>

<p>
  With these changes, after building a package, you just need to
  type <code>dput</code> (in the correct directory of course) to sign and upload
  it.
</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[pristine-tar considered harmful]]></title>
    <link href="https://michael.stapelberg.de/posts/2018-01-28-pristine-tar/"/>
    <id>https://michael.stapelberg.de/posts/2018-01-28-pristine-tar/</id>
    <published>2018-01-28T21:20:00+01:00</published>
    <updated>2019-02-04T19:08:45+01:00</updated>
    <content type="html"><![CDATA[<p>
  If you want to follow along at home, clone this repository:
</p>

<pre>
% GBP_CONF_FILES=:debian/gbp.conf gbp clone https://anonscm.debian.org/git/pkg-go/packages/golang-github-go-macaron-inject.git
</pre>

<p>
  Now, in the <code>golang-github-go-macaron-inject</code> directory, I’m aware
  of three ways to obtain an orig tarball (please correct me if there are more):
</p>

<ol>
  <li>
    Run <code><a href="https://manpages.debian.org/stretch/git-buildpackage/gbp-buildpackage.1.en.html">gbp
    buildpackage</a></code>, creating an orig tarball from git
    (<code>upstream/0.0_git20160627.0.d8a0b86</code>)<br>
    The resulting sha1sum is <code>d085a04b7b35856be24f8cc4a9a6d9799cdb59b4</code>.
  </li>
  <li>
    Run <code><a href="https://manpages.debian.org/stretch/pristine-tar/pristine-tar.1.en.html">pristine-tar</a>
    checkout</code><br>
    The resulting sha1sum is <code>d51575c0b00db5fe2bbf8eea65bc7c4f767ee954</code>.
  </li>
  <li>
    Run <code><a href="https://manpages.debian.org/stretch/devscripts/origtargz.1.en.html">origtargz</a></code><br>
    The resulting sha1sum is <code>d51575c0b00db5fe2bbf8eea65bc7c4f767ee954</code>.
  </li>
</ol>

<p>
  Have a look at the
  archive’s <a href="https://deb.debian.org/debian/pool/main/g/golang-github-go-macaron-inject/golang-github-go-macaron-inject_0.0~git20160627.0.d8a0b86-2.dsc">golang-github-go-macaron-inject_0.0~git20160627.0.d8a0b86-2.dsc</a>,
  however: the file entry orig tarball reads:
</p>

<pre>
f5d5941c7b77e8941498910b64542f3db6daa3c2 7688 golang-github-go-macaron-inject_0.0~git20160627.0.d8a0b86.orig.tar.xz
</pre>

<p>
  So, why did we get a different tarball? Let’s go through the methods:
</p>

<ol>
  <li>
    The uploader must not have used <code>gbp buildpackage</code> to create
    their tarball. Perhaps they imported from a tarball created by
    dh-make-golang, or created manually, and then left that tarball in place
    (which is a perfectly fine, normal workflow).
  </li>

  <li>
    I’m not entirely sure why <code>pristine-tar</code> resulted in a different
    tarball than what’s in the archive. I think the most likely theory is that
    the uploader had to go back and modify the tarball, but forgot to update (or
    made a mistake while updating) the pristine-tar branch.
  </li>
  
  <li>
    <code>origtargz</code>, when it detects pristine-tar data, uses
    pristine-tar, hence the same tarball as ②.
  </li>
</ol>

<p>
  Had we not used pristine-tar for this repository at
  all, <code>origtargz</code> would have pulled the correct tarball from the
  archive.
</p>

<p>
  The above anecdote illustrates the fragility of the pristine-tar approach. In
  my experience from the pkg-go team, when the pristine-tar branch doesn’t
  contain outright incorrect data, it is often outdated. Even when everything is
  working correctly, a number of packagers are disgruntled about the extra
  work/mental complexity.
</p>

<p>
  In the pkg-go team, we have (independently of this specific anecdote)
  collectively decided to have the upstream branch track the upstream remote’s
  master (or similar) branch directly, and get rid of pristine-tar in our
  repositories. This should result in method ① and ③ working correctly.
</p>

<p>
  In conclusion, my recommendation for any repository is: don’t bother with
  pristine-tar. Instead, configure <code>origtargz</code> as a git-buildpackage
  postclone hook in your <code>~/.gbp.conf</code> to always work with archive
  orig tarballs:
</p>

<pre>
[clone]
# Ensure the correct orig tarball is present.
postclone=origtargz

[buildpackage]
# Pick up the orig tarballs created by the origtargz postclone hook.
tarball-dir = ..
</pre>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Off-site backups with an apu2c4]]></title>
    <link href="https://michael.stapelberg.de/posts/2018-01-13-offsite-backup-apu2c4/"/>
    <id>https://michael.stapelberg.de/posts/2018-01-13-offsite-backup-apu2c4/</id>
    <published>2018-01-13T17:30:00+01:00</published>
    <updated>2018-03-18T21:51:55+01:00</updated>
    <content type="html"><![CDATA[

<h3 id="background">Background</h3>

<p>A short summary of my backup strategy is: I run daily backups to my
<a href="/Artikel/gigabit-nas-coreos">NAS</a>. In order to recover from risks like my
apartment burning down or my belongings being stolen, I like to keep one copy of
my data off-site, updated less frequently.</p>

<p>I used to store off-site backups with the “unlimited storage” offerings of
various cloud providers.</p>

<p>These offers follow a similar pattern: they are announced, people sign up and
use a large amount of storage, the provider realizes they cannot make enough
money off of this pricing model, and finally the offer is cancelled.</p>

<p>I went through this two times, and my friend Mark’s <a href="https://bryars.eu/2017/10/backup-pi/">similar experience and
home-grown solution</a> inspired me to also
build my own off-site backup.</p>

<h3 id="introduction">Introduction</h3>

<p>I figured the office would make a good place for an external hard disk: I’m
there every workday, it’s not too far away, and there is good internet
connectivity for updating the off-site backup.</p>

<p>Initially, I thought just leaving the external hard disk there and updating it
over night by bringing my laptop to the office every couple of weeks would be
sufficient.</p>

<p>Now I know that strategy doesn’t work for me: the time would never be good
(“maybe I’ll unexpectedly need my laptop tonight!”), I would forget, or I would
not be in the mood.</p>

<p>Lesson learnt: <strong>backups must not require continuous human involvement</strong>.</p>

<p>The rest of this article covers the hardware I decided to use and the software
setup.</p>

<h3 id="hardware">Hardware</h3>

<p>The external hard disk enclosure is a <a href="https://www.alternate.de/Sharkoon/Swift-Case-PRO-USB-3-0-Laufwerksgeh%C3%A4use/html/product/1148212">T3US41 Sharkoon Swift Case PRO USB
3.0</a>
for 25 €.</p>

<p>The enclosed disk is a HGST 8TB drive for which I paid 290 € in mid 2017.</p>

<p>For <a href="/Artikel/rgb2r-network">providing internet at our yearly retro computing
event</a>, I still had a <a href="https://pcengines.ch/apu2c4.htm">PC Engines
apu2c4</a> lying around, which I repurposed for my
off-site backups. For this year’s retro computing event, I’ll either borrow it
(setting it up is quick) or buy another one.</p>

<p>The apu2c4 has two USB 3.0 ports, so I can connect my external hard disk to it
without USB being a bottle-neck.</p>

<h3 id="setup-installation">Setup: installation</h3>

<p>On the apu2c4, I installed Debian “stretch” 9, the latest Debian stable version
at the time of writing. I prepared a USB thumb drive with the netinst image:</p>

<pre><code>% wget https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/debian-9.2.1-amd64-netinst.iso
% cp debian-9.2.1-amd64-netinst.iso /dev/sdb
</code></pre>

<p>Then, I…</p>

<ul>
<li>plugged the USB thumb drive into the apu2c4</li>
<li>On the serial console, pressed F10 (boot menu), then 1 (boot from USB)</li>
<li>In the Debian installer, selected Help, pressed F6 (special boot parameters), entered <code>install console=ttyS0,115200n8</code></li>
<li>installed Debian as usual.</li>
<li>Manually ran <code>update-grub</code>, so that GRUB refers to the boot disk by UUID instead of <code>root=/dev/sda1</code>. Especially once the external hard disk is connected, device nodes are unstable.</li>
<li>On the serial console, pressed F10 (boot menu), then 4 (setup), then c to move the mSATA SSD to number 1 in boot order</li>
<li>Connected the external hard disk</li>
</ul>

<h3 id="setup-persistent-reverse-ssh-tunnel">Setup: persistent reverse SSH tunnel</h3>

<p>I’m connecting the apu2c4 to a guest network port in our office, to keep it
completely separate from our corporate infrastructure. Since we don’t have
permanently assigned publically reachable IP addresses on that guest network, I
needed to set up a reverse tunnel.</p>

<p>First, I created an SSH private/public keypair using <a href="https://manpages.debian.org/stretch/openssh-client/ssh-keygen.1"><code>ssh-keygen(1)</code></a>.</p>

<p>Then, I created a user account for the apu2c4 on my NAS (using cloud-config),
where the tunnel will be terminated. This account’s SSH usage is restricted to
port forwardings only:</p>

<pre><code>users:
  - name: apu2c4
    system: true
    ssh-authorized-keys:
      - &quot;restrict,command=\&quot;/bin/false\&quot;,port-forwarding ssh-rsa AAAA…== root@stapelberg-apu2c4&quot;
</code></pre>

<p>On the apu2c4, I installed the <code>autossh</code> Debian package (see the
<a href="https://manpages.debian.org/stretch/autossh/autossh.1"><code>autossh(1)</code></a> manpage
for details) and created the systemd unit file
<code>/etc/systemd/system/autossh-nas.service</code> with the following content:</p>

<pre><code>[Unit]
Description=autossh reverse tunnel
After=network.target
Wants=network-online.target

[Service]
Restart=always
StartLimitIntervalSec=0
Environment=AUTOSSH_GATETIME=0
ExecStart=/usr/bin/autossh -M 0 -N -o &quot;ServerAliveInterval 60&quot; -o &quot;ServerAliveCountMax 3&quot; -o &quot;ExitOnForwardFailure yes&quot; apu2c4@nas.example.net -R 2200:localhost:22

[Install]
WantedBy=multi-user.target
</code></pre>

<p>After enabling and starting the unit using <code>systemctl enable --now autossh-nas</code>,
the apu2c4 connected to the NAS and set up a reverse port-forwarding.</p>

<p>On the NAS, I configure SSH like so in my <code>/root/.ssh/config</code>:</p>

<pre><code>Host apu2c4
  Hostname localhost
  Port 2200
  User root
  IdentitiesOnly yes
</code></pre>

<p>Finally, I authorized the public key of my NAS to connect to the apu2c4.</p>

<p>Note that this concludes the setup of the apu2c4: the device’s only purpose is
to make the external hard disk drive available remotely to my NAS, clean and
simple.</p>

<h3 id="setup-full-disk-encryption">Setup: full-disk encryption</h3>

<p>I decided to not store the encryption key for the external hard disk on the
apu2c4, to have piece of mind in case the hard disk gets misplaced or even
stolen. Of course I trust my co-workers, but this is a matter of principle.</p>

<p>Hence, I amended my NAS’s cloud-config setup like so (of course with a stronger
key):</p>

<pre><code>write_files:
  - path: /root/apu2c4.lukskey
    permissions: 0600
    owner: root:root
    content: |
    ABCDEFGHIJKL0123456789
</code></pre>

<p>…and configured the second key slot of the external hard disk to use this key.</p>

<h3 id="setup-backup-script">Setup: Backup script</h3>

<p>I’m using a script roughly like the following to do the actual backups:</p>

<pre><code>#!/bin/bash
# vi:ts=4:sw=4:et
set -e

/bin/ssh apu2c4 cryptsetup luksOpen --key-file - /dev/disk/by-id/ata-HGST_HDN1234 offline_crypt &lt; /root/apu2c4.lukskey

/bin/ssh apu2c4 mount /dev/mapper/offline_crypt /mnt/offsite

# step 1: update everything but /backups
echo &quot;$(date +'%c') syncing NAS data&quot;

(cd /srv &amp;&amp; /usr/bin/rsync --filter 'exclude /backup' -e ssh -ax --relative --numeric-ids ./ apu2c4:/mnt/offsite)

# step 2: copy the latest backup
hosts=$(ls /srv/backup/)
for host in $hosts
do
  latestremote=$(ls /srv/backup/${host}/ | tail -1)
  latestlocal=$(/bin/ssh apu2c4 ls /mnt/offsite/backup/${host} | tail -1)
  if [ &quot;$latestlocal&quot; != &quot;$latestremote&quot; ]
  then
    echo &quot;$(date +'%c') syncing $host (offline: ${latestlocal}, NAS: ${latestremote})&quot;
    /bin/ssh apu2c4 mkdir -p /mnt/offsite/backup/${host}
    (cd /srv &amp;&amp; /usr/bin/rsync -e ssh -ax --numeric-ids ./backup/${host}/${latestremote}/ apu2c4:/mnt/offsite/backup/${host}/${latestremote} --link-dest=../${latestlocal})

    # step 3: delete all previous backups
    echo &quot;$(date +'%c') deleting everything but ${latestremote} for host ${host}&quot;
    ssh apu2c4 &quot;find /mnt/offsite/backup/${host} \! \( -path \&quot;/mnt/offsite/backup/${host}/${latestremote}/*\&quot; -or -path \&quot;/mnt/offsite/backup/${host}/${latestremote}\&quot; -or -path \&quot;/mnt/offsite/backup/${host}\&quot; \) -delete&quot;
  fi
done

/bin/ssh apu2c4 umount /mnt/offsite
/bin/ssh apu2c4 cryptsetup luksClose offline_crypt
/bin/ssh apu2c4 hdparm -Y /dev/disk/by-id/ata-HGST_HDN1234
</code></pre>

<p>Note that this script is not idempotent, lacking in error handling and won’t be
updated. It merely serves as an illustration of how things could work, but
specifics depend on your backup.</p>

<p>To run this script weekly, I created the following cloud-config on my NAS:</p>

<pre><code>coreos:
  units:
    - name: sync-offsite.timer
      command: start
      content: |
        [Unit]
        Description=sync backups to off-site storage

        [Timer]
        OnCalendar=Sat 03:00

    - name: sync-offsite.service
      content: |
        [Unit]
        Description=sync backups to off-site storage
        After=docker.service srv.mount
        Requires=docker.service srv.mount

        [Service]
        Type=oneshot

        ExecStart=/root/sync-offsite-backup.sh
</code></pre>

<h3 id="improvement-bandwidth-throttling">Improvement: bandwidth throttling</h3>

<p>In case your office (or off-site place) doesn’t have a lot of bandwidth
available, consider throttling your backups. Thus far, I haven’t had the need.</p>

<h3 id="improvement-rtc-based-wake-up">Improvement: RTC-based wake-up</h3>

<p>I couldn’t figure out whether the apu2c4 supports waking up based on a real-time
clock (RTC), and if yes, whether that works across power outages.</p>

<p>If so, one could keep it shut down (or suspended) during the week, and only
power it up for the actual backup update. The downside of course is that
any access (such as for restoring remotely) require physical presence.</p>

<p>If you know the answer, please send me an email.</p>

<h3 id="conclusion">Conclusion</h3>

<p>The presented solution is easier to integrate than most cloud storage
solutions.</p>

<p>Of course my setup is less failure-tolerant than decent cloud storage providers,
but given the low probability of a catastrophic event (e.g. apartment burning
down), it’s fine to just order a new hard disk or apu2c4 when either of the two
fails — for this specific class of backups, that’s an okay trade-off to make.</p>

<p>The upside of my setup is that the running costs are very low: the apu2c4’s few
watts of electricity usage are lost in the noise, and syncing a few hundred MB
every week is cheap enough these days.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Debian buster on the Raspberry Pi 3 (update)]]></title>
    <link href="https://michael.stapelberg.de/posts/2018-01-08-raspberry-pi-3/"/>
    <id>https://michael.stapelberg.de/posts/2018-01-08-raspberry-pi-3/</id>
    <published>2018-01-08T22:55:00+01:00</published>
    <updated>2019-02-04T19:08:45+01:00</updated>
    <content type="html"><![CDATA[<p>
I previously wrote about <a
href="https://people.debian.org/~stapelberg/2017/10/08/raspberry-pi-3.html">my
Debian buster preview image for the Raspberry Pi 3</a>.
</p>

<p>
Now, I’m publishing an updated version, containing the following changes:
</p>
<ul>
<li>
WiFi works out of the box. Use e.g. <code>ip link set dev wlan0 up</code>, and <code>iwlist wlan0 scan</code>.
</li>
<li>
Kernel boot messages are now displayed on an attached monitor (if any), not just on the serial console.
</li>
<li>
Root file system resizing will now not touch the partition table if the user modified it.
</li>
<li>
The image is now compressed using xz, reducing its size to 170M.
</li>
</ul>

<p>
As before, the image is built
with <a href="https://github.com/larswirzenius/vmdb2">vmdb2</a>, the successor
to vmdebootstrap. The input files are available
at <a href="https://github.com/Debian/raspi3-image-spec">https://github.com/Debian/raspi3-image-spec</a>.
</p>

<p>
Note that Bluetooth is still untested
(see <a href="https://wiki.debian.org/RaspberryPi3">wiki:RaspberryPi3</a> for
details).
</p>

<p>
Given that Bluetooth is the only known issue, I’d like to work towards getting
this image built and provided on official Debian infrastructure. If you know how
to make this happen, please send me an email. Thanks!
</p>

<p>
As a <strong>preview version</strong> (i.e. unofficial, unsupported, etc.)
until that’s done, I built and uploaded the resulting image. Find it at <a
href="https://people.debian.org/~stapelberg/raspberrypi3/2018-01-08/">https://people.debian.org/~stapelberg/raspberrypi3/2018-01-08/</a>.
To install the image, insert the SD card into your computer (I’m assuming it’s
available as <code>/dev/sdb</code>) and copy the image onto it:
</p>

<pre>
$ wget https://people.debian.org/~stapelberg/raspberrypi3/2018-01-08/2018-01-08-raspberry-pi-3-buster-PREVIEW.img.xz
$ xzcat 2018-01-08-raspberry-pi-3-buster-PREVIEW.img.xz | dd of=/dev/sdb bs=64k oflag=dsync status=progress
</pre>

<p>
If resolving client-supplied DHCP hostnames works in your network, you should
be able to log into the Raspberry Pi 3 using SSH after booting it:
</p>

<pre>
$ ssh root@rpi3
# Password is “raspberry”
</pre>
]]></content>
  </entry>
</feed>
