<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Michael Stapelbergs Website: posts tagged debian</title>
  <link href="https://michael.stapelberg.ch/posts/tags/debian/feed.xml" rel="self"/>
  <link href="https://michael.stapelberg.ch/posts/tags/debian/"/>
  <updated>2019-02-15T00:00:00+00:00</updated>
  <id>https://michael.stapelberg.ch/posts/tags/debian/</id>
  <generator>Hugo -- gohugo.io</generator>
  <entry>
    <title type="html"><![CDATA[Debugging experience in Debian]]></title>
    <link href="https://michael.stapelberg.ch/posts/2019-02-15-debian-debugging-devex/"/>
    <id>https://michael.stapelberg.ch/posts/2019-02-15-debian-debugging-devex/</id>
    <published>2019-02-15T00:00:00+00:00</published>
    <updated>2019-02-15T13:11:01+01:00</updated>
    <content type="html"><![CDATA[

<p>Recently, a user reported that <a href="https://bugs.debian.org/918925">they don’t see window titles in i3 when running
i3 on a Raspberry Pi with Debian</a>.</p>

<p>I copied the latest <a href="https://wiki.debian.org/RaspberryPi3">Raspberry Pi Debian
image</a> onto an SD card, booted it, and was
able to reproduce the issue.</p>

<p>Conceptually, at this point, I should be able to install and start <code>gdb</code>, set a
break point and step through the code.</p>

<h3 id="enabling-debug-symbols-in-debian">Enabling debug symbols in Debian</h3>

<p>Debian, by default, strips debug symbols when building packages to conserve disk
space and network bandwidth. The motivation is very reasonable: most users will
never need the debug symbols.</p>

<p>Unfortunately, obtaining debug symbols when you do need them is unreasonably hard.</p>

<p>We begin by configuring an additional apt repository which contains
automatically generated debug packages:</p>

<pre><code>raspi# cat &gt;&gt;/etc/apt/sources.list.d/debug.list &lt;&lt;'EOT'
deb http://deb.debian.org/debian-debug buster-debug main contrib non-free
EOT
raspi# apt update
</code></pre>

<p>Notably, not all Debian packages have debug packages. As <a href="https://wiki.debian.org/DebugPackage">the DebugPackage
Debian Wiki page</a> explains,
<code>debhelper/9.20151219</code> started generating debug packages (ending in <code>-dbgsym</code>)
automatically. Packages which have not been updated might come with their own
debug packages (ending in <code>-dbg</code>) or might not preserve debug symbols at all!</p>

<p>Now that we <strong>can</strong> install debug packages, how do we know <strong>which ones</strong> we need?</p>

<h3 id="finding-debug-symbol-packages-in-debian">Finding debug symbol packages in Debian</h3>

<p>For debugging i3, we obviously need at least the <code>i3-dbgsym</code> package, but i3
uses a number of other libraries through whose code we may need to step.</p>

<p>The <code>debian-goodies</code> package ships a tool called
<a href="https://manpages.debian.org/testing/debian-goodies/find-dbgsym-packages.1.en.html">find-dbgsym-packages</a>
which prints the required packages to debug an executable, core dump or running
process:</p>

<pre><code>raspi# apt install debian-goodies
raspi# apt install $(find-dbgsym-packages $(which i3))
</code></pre>

<p>Now we should have symbol names and line number information available in
<code>gdb</code>. But for effectively stepping through the program, access to the source
code is required.</p>

<h3 id="obtaining-source-code-in-debian">Obtaining source code in Debian</h3>

<p>Naively, one would assume that <code>apt source</code> should be sufficient for obtaining
the source code of any Debian package. However, <code>apt source</code> defaults to the
package candidate version, not the version you have installed on your
system.</p>

<p>I have addressed this issue with the
<a href="https://manpages.debian.org/testing/pk4/pk4.1.en.html"><code>pk4</code></a> tool, which
defaults to the installed version.</p>

<p>Before we can extract any sources, we need to configure yet another apt
repository:</p>

<pre><code>raspi# cat &gt;&gt;/etc/apt/sources.list.d/source.list &lt;&lt;'EOT'
deb-src http://deb.debian.org/debian buster main contrib non-free
EOT
raspi# apt update
</code></pre>

<p>Regardless of whether you use <code>apt source</code> or <code>pk4</code>, one remaining problem is
the directory mismatch: the debug symbols contain a certain path, and that path
is typically not where you extracted your sources to. While debugging, you will
need to tell <code>gdb</code> about the location of the sources. This is tricky when you
debug a call across different source packages:</p>

<pre><code>(gdb) pwd
Working directory /usr/src/i3.
(gdb) list main
229     * the main loop. */
230     ev_unref(main_loop);
231   }
232 }
233
234 int main(int argc, char *argv[]) {
235  /* Keep a symbol pointing to the I3_VERSION string constant so that
236   * we have it in gdb backtraces. */
237  static const char *_i3_version __attribute__((used)) = I3_VERSION;
238  char *override_configpath = NULL;
(gdb) list xcb_connect
484	../../src/xcb_util.c: No such file or directory.
</code></pre>

<p>See <a href="https://sourceware.org/gdb/onlinedocs/gdb/Source-Path.html">Specifying Source
Directories</a> in the
gdb manual for the <code>dir</code> command which allows you to add multiple directories to
the source path. This is pretty tedious, though, and does not work for all
programs.</p>

<h3 id="positive-example-fedora">Positive example: Fedora</h3>

<p>While Fedora conceptually shares all the same steps, the experience on Fedora is
so much better: when you run <code>gdb /usr/bin/i3</code>, it will tell you what the next
step is:</p>

<pre><code># gdb /usr/bin/i3
[…]
Reading symbols from /usr/bin/i3...(no debugging symbols found)...done.
Missing separate debuginfos, use: dnf debuginfo-install i3-4.16-1.fc28.x86_64
</code></pre>

<p>Watch what happens when we run the suggested command:</p>

<pre><code># dnf debuginfo-install i3-4.16-1.fc28.x86_64
enabling updates-debuginfo repository
enabling fedora-debuginfo repository
[…]
Installed:
  i3-debuginfo.x86_64 4.16-1.fc28
  i3-debugsource.x86_64 4.16-1.fc28
Complete!
</code></pre>

<p>A single command understood our intent, enabled the required repositories and
installed the required packages, both for debug symbols and source code (stored
in e.g. <code>/usr/src/debug/i3-4.16-1.fc28.x86_64</code>). Unfortunately, <code>gdb</code> doesn’t
seem to locate the sources, which seems like a bug to me.</p>

<p>One downside of Fedora’s approach is that <code>gdb</code> will only print all required
dependencies once you actually run the program, so you may need to run multiple
<code>dnf</code> commands.</p>

<h3 id="in-an-ideal-world">In an ideal world</h3>

<p>Ideally, none of the manual steps described above would be necessary. It seems
absurd to me that so much knowledge is required to efficiently debug programs in
Debian. Case in point: I only learnt about <code>find-dbgsym-packages</code> a few days ago
when talking to one of its contributors.</p>

<p>Installing <code>gdb</code> should be all that a user needs to do. Debug symbols and
sources can be transparently provided through a lazy-loading FUSE file
system. If our build/packaging infrastructure assured predictable paths and
automated debug symbol extraction, we could have transparent, quick and reliable
debugging of all programs within Debian.</p>

<p>NixOS’s dwarffs is an implementation of this idea:
<a href="https://github.com/edolstra/dwarffs">https://github.com/edolstra/dwarffs</a></p>

<h3 id="conclusion">Conclusion</h3>

<p>While I agree with the removal of debug symbols as a general optimization, I
think every Linux distribution should strive to provide an entirely transparent
debugging experience: you should not even have to know that debug symbols are
not present by default. Debian really falls short in this regard.</p>

<p>Getting Debian to a fully transparent debugging experience requires a lot of
technical work and a lot of social convincing. In my experience,
programmatically working with the Debian archive and packages is tricky, and
ensuring that <em>all</em> packages in a Debian release have debug packages (let alone
predictable paths) seems entirely unachievable due to the fragmentation of
packaging infrastructure and holdouts blocking any progress.</p>

<p>My go-to example is <a href="https://sources.debian.org/src/rsync/3.1.3-5/debian/rules/">rsync’s
debian/rules</a>, which
intentionally (!) still has not adopted debhelper. It is not a surprise that
there are no debug symbols for <code>rsync</code> in Debian.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[TurboPFor: an analysis]]></title>
    <link href="https://michael.stapelberg.ch/posts/2019-02-05-turbopfor-analysis/"/>
    <id>https://michael.stapelberg.ch/posts/2019-02-05-turbopfor-analysis/</id>
    <published>2019-02-05T09:00:00+01:00</published>
    <updated>2019-02-05T09:18:07+01:00</updated>
    <content type="html"><![CDATA[

<h3 id="motivation">Motivation</h3>

<p>I have recently been looking into speeding up Debian Code Search. As a quick
reminder, search engines answer queries by consulting an inverted index: a map
from term to documents containing that term (called a “posting list”). See <a href="https://codesearch.debian.net/research/bsc-thesis.pdf">the
Debian Code Search Bachelor
Thesis</a> (PDF) for a lot
more details.</p>

<p>Currently, Debian Code Search does not store positional information in its
index, i.e. the index can only reveal <em>that</em> a certain trigram is present in a
document, not <em>where</em> or <em>how often</em>.</p>

<p>From analyzing Debian Code Search queries, I knew that identifier queries (70%)
massively outnumber regular expression queries (30%). When processing identifier
queries, storing positional information in the index enables a significant
optimization: instead of identifying the possibly-matching documents and having
to read them all, we can determine matches from querying the index alone, no
document reads required.</p>

<p>This moves the bottleneck: having to read all possibly-matching documents
requires a lot of expensive random I/O, whereas having to decode long posting
lists requires a lot of cheap sequential I/O.</p>

<p>Of course, storing positions comes with a downside: the index is larger, and a
larger index takes more time to decode when querying.</p>

<p>Hence, I have been looking at various posting list compression/decoding
techniques, to figure out whether we could switch to a technique which would
retain (or improve upon!) current performance despite much longer posting lists
and produce a small enough index to fit on our current hardware.</p>

<h3 id="literature">Literature</h3>

<p>I started looking into this space because of Daniel Lemire’s <a href="https://lemire.me/blog/2017/09/27/stream-vbyte-breaking-new-speed-records-for-integer-compression/">Stream
VByte</a>
post. As usual, Daniel’s work is well presented, easily digestible and
accompanied by not just one, but multiple implementations.</p>

<p>I also looked for scientific papers to learn about the state of the art and
classes of different approaches in general. The best I could find is
<a href="https://dl.acm.org/citation.cfm?doid=2682862.2682870">Compression, SIMD, and Postings
Lists</a>. If you don’t have
access to the paper, I hear that
<a href="https://en.wikipedia.org/wiki/Sci-Hub">Sci-Hub</a> is helpful.</p>

<p>The paper is from 2014, and doesn’t include all algorithms. If you know of a
better paper, please let me know and I’ll include it here.</p>

<p>Eventually, I stumbled upon an algorithm/implementation called TurboPFor, which
the rest of the article tries to shine some light on.</p>

<h3 id="turbopfor">TurboPFor</h3>

<p>If you’re wondering: PFor stands for Patched Frame Of Reference and describes a
family of algorithms. The principle is explained e.g. in <a href="https://arxiv.org/pdf/1401.6399.pdf">SIMD Compression and
the Intersection of Sorted Integers (PDF)</a>.</p>

<p>The <a href="https://github.com/powturbo/TurboPFor">TurboPFor project’s README file</a>
claims that TurboPFor256 compresses with a rate of 5.04 bits per integer, and
can decode with 9400 MB/s on a single thread of an Intel i7-6700 CPU.</p>

<p>For Debian Code Search, we use unsigned integers of 32 bit (uint32), which
TurboPFor will compress into as few bits as required.</p>

<p>Dividing Debian Code Search’s file sizes by the total number of integers, I get
similar values, at least for the docid index section:</p>

<ul>
<li>5.49 bits per integer for the docid index section</li>
<li>11.09 bits per integer for the positions index section</li>
</ul>

<p>I can confirm the order of magnitude of the decoding speed, too. My benchmark
calls TurboPFor from Go via cgo, which introduces some overhead. To exclude disk
speed as a factor, data comes from the page cache. The benchmark sequentially
decodes all posting lists in the specified index, using as many threads as the
machine has cores¹:</p>

<ul>
<li>≈1400 MB/s on a  1.1 GiB docid index section</li>
<li>≈4126 MB/s on a 15.0 GiB position index section</li>
</ul>

<p>I think the numbers differ because the position index section contains larger
integers (requiring more bits). I repeated both benchmarks, capped to 1 GiB, and
decoding speeds still differed, so it is not just the size of the index.</p>

<p>Compared to Streaming VByte, a TurboPFor256 index comes in at just over half the
size, while still reaching 83% of Streaming VByte’s decoding speed. This seems
like a good trade-off for my use-case, so I decided to have a closer look at how
TurboPFor works.</p>

<p>① See <a href="https://github.com/stapelberg/goturbopfor/blob/d7954fb81e66080941891dccc27407d8496f65d9/cmd/gp4-verify/verify.go">cmd/gp4-verify/verify.go</a> run on an Intel i9-9900K.</p>

<h3 id="methodology">Methodology</h3>

<p>To confirm my understanding of the details of the format, I implemented a
pure-Go TurboPFor256 decoder. Note that it is intentionally <em>not optimized</em> as
its main goal is to use simple code to teach the TurboPFor256 on-disk format.</p>

<p>If you’re looking to use TurboPFor from Go, I recommend using cgo. cgo’s
function call overhead is about 51ns <a href="https://go-review.googlesource.com/c/go/+/30080">as of Go
1.8</a>, which will easily be
offset by TurboPFor’s carefully optimized, vectorized (SSE/AVX) code.</p>

<p>With that caveat out of the way, you can find my teaching implementation at
<a href="https://github.com/stapelberg/goturbopfor">https://github.com/stapelberg/goturbopfor</a></p>

<p>I verified that it produces the same results as TurboPFor’s <code>p4ndec256v32</code>
function for all posting lists in the Debian Code Search index.</p>

<h3 id="on-disk-format">On-disk format</h3>

<p>Note that TurboPFor does not fully define an on-disk format on its own. When
encoding, it turns a list of integers into a byte stream:</p>

<pre><code>size_t p4nenc256v32(uint32_t *in, size_t n, unsigned char *out);
</code></pre>

<p>When decoding, it decodes the byte stream into an array of integers, but needs
to know the number of integers in advance:</p>

<pre><code>size_t p4ndec256v32(unsigned char *in, size_t n, uint32_t *out);
</code></pre>

<p>Hence, you’ll need to keep track of the number of integers and length of the
generated byte streams separately. When I talk about on-disk format, I’m
referring to the byte stream which TurboPFor returns.</p>

<p>The TurboPFor256 format uses blocks of 256 integers each, followed by a trailing
block — if required — which can contain fewer than 256 integers:</p>

<p><img src="/turbopfor/ondisk.svgo.svg"></p>

<p>SIMD bitpacking is used for all blocks but the trailing block (which uses
regular bitpacking). This is not merely an implementation detail for decoding:
the on-disk structure is different for blocks which can be SIMD-decoded.</p>

<p>Each block starts with a 2 bit header, specifying the type of the block:</p>

<ul>
<li>11: <a href="#block-constant">constant</a></li>
<li>00: <a href="#block-bitpack">bitpacking</a></li>
<li>10: <a href="#block-bitpackex">bitpacking with exceptions (bitmap)</a></li>
<li>01: <a href="#block-bitpackvb">bitpacking with exceptions (variable byte)</a></li>
</ul>

<p>Each block type is explained in more detail in the following sections.</p>

<p>Note that none of the block types store the number of elements: you will always
need to know how many integers you need to decode. Also, you need to know in
advance how many bytes you need to feed to TurboPFor, so you will need some sort
of container format.</p>

<p>Further, TurboPFor automatically choses the best block type for each block.</p>

<h4 id="block-constant">Constant block</h4>

<p>A constant block (all integers of the block have the same value) consists of a
single value of a specified bit width ≤ 32. This value will be stored in each
output element for the block. E.g., after calling <code>decode(input, 3, output)</code>
with <code>input</code> being the constant block depicted below, output is <code>{0xB8912636,
0xB8912636, 0xB8912636}</code>.</p>

<p><img src="/turbopfor/block-constant.svgo.svg"></p>

<p>The example shows the maximum number of bytes (5). Smaller integers will use
fewer bytes: e.g. an integer which can be represented in 3 bits will only use 2
bytes.</p>

<h4 id="block-bitpack">Bitpacking block</h4>

<p>A bitpacking block specifies a bit width ≤ 32, followed by a stream of
bits. Each value starts at the Least Significant Bit (LSB), i.e. the 3-bit
values 0 (<code>000b</code>) and 5 (<code>101b</code>) are encoded as <code>101000b</code>.</p>

<p><img src="/turbopfor/block-bitpack.svgo.svg"></p>

<h4 id="block-bitpackex">Bitpacking with exceptions (bitmap) block</h4>

<p>The constant and bitpacking block types work well for integers which don’t
exceed a certain width, e.g. for a series of integers of width ≤ 5 bits.</p>

<p>For a series of integers where only a few values exceed an otherwise common
width (say, two values require 7 bits, the rest requires 5 bits), it makes sense
to cut the integers into two parts: value and exception.</p>

<p>In the example below, decoding the third integer <code>out2</code> (<code>000b</code>) requires
combination with exception <code>ex0</code> (<code>10110b</code>), resulting in <code>10110000b</code>.</p>

<p>The number of exceptions can be determined by summing the 1 bits in the bitmap
using the <a href="https://en.wikipedia.org/wiki/Hamming_weight">popcount instruction</a>.</p>

<p><img src="/turbopfor/block-bitpackex.svgo.svg"></p>

<h4 id="block-bitpackvb">Bitpacking with exceptions (variable byte)</h4>

<p>When the exceptions are not uniform enough, it makes sense to switch from
bitpacking to a variable byte encoding:</p>

<p><img src="/turbopfor/block-bitpackvb.svgo.svg"></p>

<h3 id="decoding-variable-byte">Decoding: variable byte</h3>

<p>The variable byte encoding used by the TurboPFor format is similar to the one
<a href="https://sqlite.org/src4/doc/trunk/www/varint.wiki">used by SQLite</a>, which is
described, alongside other common variable byte encodings, at
<a href="https://github.com/stoklund/varint">github.com/stoklund/varint</a>.</p>

<p>Instead of using individual bits for dispatching, this format classifies the
first byte (<code>b[0]</code>) into ranges:</p>

<ul>
<li>[0—176]: the value is <code>b[0]</code></li>
<li>[177—240]: a 14 bit value is in <code>b[0]</code> (6 high bits) and <code>b[1]</code> (8 low bits)</li>
<li>[241—248]: a 19 bit value is in <code>b[0]</code> (3 high bits), <code>b[1]</code> and <code>b[2]</code> (16 low bits)</li>
<li>[249—255]: a 32 bit value is in <code>b[1]</code>, <code>b[2]</code>, <code>b[3]</code> and possibly <code>b[4]</code></li>
</ul>

<p>Here is the space usage of different values:</p>

<ul>
<li>[0—176] are stored in 1 byte (as-is)</li>
<li>[177—16560] are stored in 2 bytes, with the highest 6 bits added to 177</li>
<li>[16561—540848] are stored in 3 bytes, with the highest 3 bits added to 241</li>
<li>[540849—16777215] are stored in 4 bytes, with 0 added to 249</li>
<li>[16777216—4294967295] are stored in 5 bytes, with 1 added to 249</li>
</ul>

<p>An overflow marker will be used to signal that encoding the
values would be less space-efficient than simply copying them
(e.g. if all values require 5 bytes).</p>

<p>This format is very space-efficient: it packs 0-176 into a single byte, as
opposed to 0-128 (most others). At the same time, it can be decoded very
quickly, as only the first byte needs to be compared to decode a value (similar
to PrefixVarint).</p>

<h3 id="decoding-bitpacking">Decoding: bitpacking</h3>

<h4 id="regular-bitpacking">Regular bitpacking</h4>

<p>In regular (non-SIMD) bitpacking, integers are stored on disk one after the
other, padded to a full byte, as a byte is the smallest addressable unit when
reading data from disk. For example, if you bitpack only one 3 bit int, you will
end up with 5 bits of padding.</p>

<p><img src="/turbopfor/bitpacking.svgo.svg"></p>

<h4 id="simd-bitpacking-256v32">SIMD bitpacking (256v32)</h4>

<p>SIMD bitpacking works like regular bitpacking, but processes 8 uint32
little-endian values at the same time, leveraging the <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX instruction
set</a>. The following
illustration shows the order in which 3-bit integers are decoded from disk:</p>

<p><img src="/turbopfor/bitpacking256v32.svgo.svg"></p>

<h3 id="in-practice">In Practice</h3>

<p>For a Debian Code Search index, 85% of posting lists are short enough to only
consist of a trailing block, i.e. no SIMD instructions can be used for decoding.</p>

<p>The distribution of block types looks as follows:</p>

<ul>
<li>72% bitpacking with exceptions (bitmap)</li>
<li>19% bitpacking with exceptions (variable byte)</li>
<li>5% constant</li>
<li>4% bitpacking</li>
</ul>

<p>Constant blocks are mostly used for posting lists with just one entry.</p>

<h3 id="conclusion">Conclusion</h3>

<p>The TurboPFor on-disk format is very flexible: with its 4 different kinds of
blocks, chances are high that a very efficient encoding will be used for most
integer series.</p>

<p>Of course, the flip side of covering so many cases is complexity: the format and
implementation take quite a bit of time to understand — hopefully this article
helps a little! For environments where the C TurboPFor implementation cannot be
used, smaller algorithms might be simpler to implement.</p>

<p>That said, if you can use the TurboPFor implementation, you will benefit from a
highly optimized SIMD code base, which will most likely be an improvement over
what you’re currently using.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Looking for a new Raspberry Pi image maintainer]]></title>
    <link href="https://michael.stapelberg.ch/posts/2018-06-03-raspi3-looking-for-maintainer/"/>
    <id>https://michael.stapelberg.ch/posts/2018-06-03-raspi3-looking-for-maintainer/</id>
    <published>2018-06-03T08:43:00+02:00</published>
    <updated>2019-02-05T09:42:13+01:00</updated>
    <content type="html"><![CDATA[<p>
  <strong>This is taken care of: Gunnar Wolf has taken on maintenance of the Raspberry Pi image. Thank you!</strong>
</p>

<p>
  (Cross-posting this message I sent to pkg-raspi-maintainers for broader visibility.)
</p>

<p>
  I started building Raspberry Pi images because I thought there should be an easy, official way to install Debian on the Raspberry Pi.
</p>

<p>
  I still believe that, but I’m not actually using Debian on any of my Raspberry Pis anymore¹, so my personal motivation to do any work on the images is gone.
</p>

<p>
  On top of that, I realize that my commitments exceed my spare time capacity, so I need to get rid of responsibilities.
</p>

<p>
  Therefore, <strong>I’m looking for someone to take up maintainership of the Raspberry Pi images</strong>. Numerous people have reached out to me with thank you notes and questions, so I think the user interest is there. Also, I’ll be happy to answer any questions that you might have and that I can easily answer. Please reply here (or in private) if you’re interested.
</p>

<p>
  If I can’t find someone within the next 7 days, I’ll put up an announcement message in the raspi3-image-spec README, wiki page, and my blog posts, stating that the image is unmaintained and looking for a new maintainer.
</p>

<p>
  Thanks for your understanding,
</p>

<p>
  ① just in case you’re curious, I’m now running cross-compiled Go programs directly under a Linux kernel and minimal userland, see <a href="https://gokrazy.org/">https://gokrazy.org/</a>
</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[sbuild-debian-developer-setup(1)]]></title>
    <link href="https://michael.stapelberg.ch/posts/2018-03-19-sbuild-debian-developer-setup/"/>
    <id>https://michael.stapelberg.ch/posts/2018-03-19-sbuild-debian-developer-setup/</id>
    <published>2018-03-19T08:00:00+01:00</published>
    <updated>2019-02-04T19:08:45+01:00</updated>
    <content type="html"><![CDATA[<p>
  I have heard a number of times that sbuild is too hard to get started with,
  and hence people don’t use it.
</p>

<p>
  To reduce hurdles from using/contributing to Debian, I wanted to make sbuild
  easier to set up.
</p>

<p>
  sbuild ≥ 0.74.0 provides a Debian package
  called <a href="https://packages.debian.org/sid/sbuild-debian-developer-setup">sbuild-debian-developer-setup</a>. Once
  installed, run
  the <a href="https://manpages.debian.org/unstable/sbuild/sbuild-debian-developer-setup.1">sbuild-debian-developer-setup(1)</a>
  command to create a chroot suitable for building packages for Debian unstable.
</p>

<p>
  On a system without any sbuild/schroot bits installed, a transcript of the
  full setup looks like this:
</p>

<pre>
% sudo apt install -t unstable sbuild-debian-developer-setup
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following additional packages will be installed:
  libsbuild-perl sbuild schroot
Suggested packages:
  deborphan btrfs-tools aufs-tools | unionfs-fuse qemu-user-static
Recommended packages:
  exim4 | mail-transport-agent autopkgtest
The following NEW packages will be installed:
  libsbuild-perl sbuild sbuild-debian-developer-setup schroot
0 upgraded, 4 newly installed, 0 to remove and 1454 not upgraded.
Need to get 1.106 kB of archives.
After this operation, 3.556 kB of additional disk space will be used.
Do you want to continue? [Y/n]
Get:1 http://localhost:3142/deb.debian.org/debian unstable/main amd64 libsbuild-perl all 0.74.0-1 [129 kB]
Get:2 http://localhost:3142/deb.debian.org/debian unstable/main amd64 sbuild all 0.74.0-1 [142 kB]
Get:3 http://localhost:3142/deb.debian.org/debian testing/main amd64 schroot amd64 1.6.10-4 [772 kB]
Get:4 http://localhost:3142/deb.debian.org/debian unstable/main amd64 sbuild-debian-developer-setup all 0.74.0-1 [62,6 kB]
Fetched 1.106 kB in 0s (5.036 kB/s)
Selecting previously unselected package libsbuild-perl.
(Reading database ... 276684 files and directories currently installed.)
Preparing to unpack .../libsbuild-perl_0.74.0-1_all.deb ...
Unpacking libsbuild-perl (0.74.0-1) ...
Selecting previously unselected package sbuild.
Preparing to unpack .../sbuild_0.74.0-1_all.deb ...
Unpacking sbuild (0.74.0-1) ...
Selecting previously unselected package schroot.
Preparing to unpack .../schroot_1.6.10-4_amd64.deb ...
Unpacking schroot (1.6.10-4) ...
Selecting previously unselected package sbuild-debian-developer-setup.
Preparing to unpack .../sbuild-debian-developer-setup_0.74.0-1_all.deb ...
Unpacking sbuild-debian-developer-setup (0.74.0-1) ...
Processing triggers for systemd (236-1) ...
Setting up schroot (1.6.10-4) ...
Created symlink /etc/systemd/system/multi-user.target.wants/schroot.service → /lib/systemd/system/schroot.service.
Setting up libsbuild-perl (0.74.0-1) ...
Processing triggers for man-db (2.7.6.1-2) ...
Setting up sbuild (0.74.0-1) ...
Setting up sbuild-debian-developer-setup (0.74.0-1) ...
Processing triggers for systemd (236-1) ...

% sudo sbuild-debian-developer-setup
The user `michael' is already a member of `sbuild'.
I: SUITE: unstable
I: TARGET: /srv/chroot/unstable-amd64-sbuild
I: MIRROR: http://localhost:3142/deb.debian.org/debian
I: Running debootstrap --arch=amd64 --variant=buildd --verbose --include=fakeroot,build-essential,eatmydata --components=main --resolve-deps unstable /srv/chroot/unstable-amd64-sbuild http://localhost:3142/deb.debian.org/debian
I: Retrieving InRelease 
I: Checking Release signature
I: Valid Release signature (key id 126C0D24BD8A2942CC7DF8AC7638D0442B90D010)
I: Retrieving Packages 
I: Validating Packages 
I: Found packages in base already in required: apt 
I: Resolving dependencies of required packages...
[…]
I: Successfully set up unstable chroot.
I: Run "sbuild-adduser" to add new sbuild users.
ln -s /usr/share/doc/sbuild/examples/sbuild-update-all /etc/cron.daily/sbuild-debian-developer-setup-update-all
Now run `newgrp sbuild', or log out and log in again.

% newgrp sbuild

% sbuild -d unstable hello
sbuild (Debian sbuild) 0.74.0 (14 Mar 2018) on x1

+==============================================================================+
| hello (amd64)                                Mon, 19 Mar 2018 07:46:14 +0000 |
+==============================================================================+

Package: hello
Distribution: unstable
Machine Architecture: amd64
Host Architecture: amd64
Build Architecture: amd64
Build Type: binary
[…]
</pre>

<p>
  I hope you’ll find this useful.
</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[dput usability changes]]></title>
    <link href="https://michael.stapelberg.ch/posts/2018-03-10-dput-usability/"/>
    <id>https://michael.stapelberg.ch/posts/2018-03-10-dput-usability/</id>
    <published>2018-03-10T10:00:00+01:00</published>
    <updated>2019-02-04T19:08:45+01:00</updated>
    <content type="html"><![CDATA[<p>
  dput-ng ≥ 1.16 contains two usability changes which make uploading easier:
</p>

<ol>
  <li>
    When no arguments are specified, dput-ng auto-selects the most recent .changes file (with confirmation).
  </li>
  <li>
    Instead of erroring out when detecting an unsigned .changes file, <a href="https://manpages.debian.org/stretch/devscripts/debsign.1">debsign(1)</a> is invoked to sign the .changes file before proceeding.
  </li>
</ol>

<p>
  With these changes, after building a package, you just need to
  type <code>dput</code> (in the correct directory of course) to sign and upload
  it.
</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[pristine-tar considered harmful]]></title>
    <link href="https://michael.stapelberg.ch/posts/2018-01-28-pristine-tar/"/>
    <id>https://michael.stapelberg.ch/posts/2018-01-28-pristine-tar/</id>
    <published>2018-01-28T21:20:00+01:00</published>
    <updated>2019-02-04T19:08:45+01:00</updated>
    <content type="html"><![CDATA[<p>
  If you want to follow along at home, clone this repository:
</p>

<pre>
% GBP_CONF_FILES=:debian/gbp.conf gbp clone https://anonscm.debian.org/git/pkg-go/packages/golang-github-go-macaron-inject.git
</pre>

<p>
  Now, in the <code>golang-github-go-macaron-inject</code> directory, I’m aware
  of three ways to obtain an orig tarball (please correct me if there are more):
</p>

<ol>
  <li>
    Run <code><a href="https://manpages.debian.org/stretch/git-buildpackage/gbp-buildpackage.1.en.html">gbp
    buildpackage</a></code>, creating an orig tarball from git
    (<code>upstream/0.0_git20160627.0.d8a0b86</code>)<br>
    The resulting sha1sum is <code>d085a04b7b35856be24f8cc4a9a6d9799cdb59b4</code>.
  </li>
  <li>
    Run <code><a href="https://manpages.debian.org/stretch/pristine-tar/pristine-tar.1.en.html">pristine-tar</a>
    checkout</code><br>
    The resulting sha1sum is <code>d51575c0b00db5fe2bbf8eea65bc7c4f767ee954</code>.
  </li>
  <li>
    Run <code><a href="https://manpages.debian.org/stretch/devscripts/origtargz.1.en.html">origtargz</a></code><br>
    The resulting sha1sum is <code>d51575c0b00db5fe2bbf8eea65bc7c4f767ee954</code>.
  </li>
</ol>

<p>
  Have a look at the
  archive’s <a href="https://deb.debian.org/debian/pool/main/g/golang-github-go-macaron-inject/golang-github-go-macaron-inject_0.0~git20160627.0.d8a0b86-2.dsc">golang-github-go-macaron-inject_0.0~git20160627.0.d8a0b86-2.dsc</a>,
  however: the file entry orig tarball reads:
</p>

<pre>
f5d5941c7b77e8941498910b64542f3db6daa3c2 7688 golang-github-go-macaron-inject_0.0~git20160627.0.d8a0b86.orig.tar.xz
</pre>

<p>
  So, why did we get a different tarball? Let’s go through the methods:
</p>

<ol>
  <li>
    The uploader must not have used <code>gbp buildpackage</code> to create
    their tarball. Perhaps they imported from a tarball created by
    dh-make-golang, or created manually, and then left that tarball in place
    (which is a perfectly fine, normal workflow).
  </li>

  <li>
    I’m not entirely sure why <code>pristine-tar</code> resulted in a different
    tarball than what’s in the archive. I think the most likely theory is that
    the uploader had to go back and modify the tarball, but forgot to update (or
    made a mistake while updating) the pristine-tar branch.
  </li>
  
  <li>
    <code>origtargz</code>, when it detects pristine-tar data, uses
    pristine-tar, hence the same tarball as ②.
  </li>
</ol>

<p>
  Had we not used pristine-tar for this repository at
  all, <code>origtargz</code> would have pulled the correct tarball from the
  archive.
</p>

<p>
  The above anecdote illustrates the fragility of the pristine-tar approach. In
  my experience from the pkg-go team, when the pristine-tar branch doesn’t
  contain outright incorrect data, it is often outdated. Even when everything is
  working correctly, a number of packagers are disgruntled about the extra
  work/mental complexity.
</p>

<p>
  In the pkg-go team, we have (independently of this specific anecdote)
  collectively decided to have the upstream branch track the upstream remote’s
  master (or similar) branch directly, and get rid of pristine-tar in our
  repositories. This should result in method ① and ③ working correctly.
</p>

<p>
  In conclusion, my recommendation for any repository is: don’t bother with
  pristine-tar. Instead, configure <code>origtargz</code> as a git-buildpackage
  postclone hook in your <code>~/.gbp.conf</code> to always work with archive
  orig tarballs:
</p>

<pre>
[clone]
# Ensure the correct orig tarball is present.
postclone=origtargz

[buildpackage]
# Pick up the orig tarballs created by the origtargz postclone hook.
tarball-dir = ..
</pre>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Debian buster on the Raspberry Pi 3 (update)]]></title>
    <link href="https://michael.stapelberg.ch/posts/2018-01-08-raspberry-pi-3/"/>
    <id>https://michael.stapelberg.ch/posts/2018-01-08-raspberry-pi-3/</id>
    <published>2018-01-08T22:55:00+01:00</published>
    <updated>2019-02-04T19:08:45+01:00</updated>
    <content type="html"><![CDATA[<p>
I previously wrote about <a
href="https://people.debian.org/~stapelberg/2017/10/08/raspberry-pi-3.html">my
Debian buster preview image for the Raspberry Pi 3</a>.
</p>

<p>
Now, I’m publishing an updated version, containing the following changes:
</p>
<ul>
<li>
WiFi works out of the box. Use e.g. <code>ip link set dev wlan0 up</code>, and <code>iwlist wlan0 scan</code>.
</li>
<li>
Kernel boot messages are now displayed on an attached monitor (if any), not just on the serial console.
</li>
<li>
Root file system resizing will now not touch the partition table if the user modified it.
</li>
<li>
The image is now compressed using xz, reducing its size to 170M.
</li>
</ul>

<p>
As before, the image is built
with <a href="https://github.com/larswirzenius/vmdb2">vmdb2</a>, the successor
to vmdebootstrap. The input files are available
at <a href="https://github.com/Debian/raspi3-image-spec">https://github.com/Debian/raspi3-image-spec</a>.
</p>

<p>
Note that Bluetooth is still untested
(see <a href="https://wiki.debian.org/RaspberryPi3">wiki:RaspberryPi3</a> for
details).
</p>

<p>
Given that Bluetooth is the only known issue, I’d like to work towards getting
this image built and provided on official Debian infrastructure. If you know how
to make this happen, please send me an email. Thanks!
</p>

<p>
As a <strong>preview version</strong> (i.e. unofficial, unsupported, etc.)
until that’s done, I built and uploaded the resulting image. Find it at <a
href="https://people.debian.org/~stapelberg/raspberrypi3/2018-01-08/">https://people.debian.org/~stapelberg/raspberrypi3/2018-01-08/</a>.
To install the image, insert the SD card into your computer (I’m assuming it’s
available as <code>/dev/sdb</code>) and copy the image onto it:
</p>

<pre>
$ wget https://people.debian.org/~stapelberg/raspberrypi3/2018-01-08/2018-01-08-raspberry-pi-3-buster-PREVIEW.img.xz
$ xzcat 2018-01-08-raspberry-pi-3-buster-PREVIEW.img.xz | dd of=/dev/sdb bs=64k oflag=dsync status=progress
</pre>

<p>
If resolving client-supplied DHCP hostnames works in your network, you should
be able to log into the Raspberry Pi 3 using SSH after booting it:
</p>

<pre>
$ ssh root@rpi3
# Password is “raspberry”
</pre>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Which VCS do Debian’s Go package upstreams use?]]></title>
    <link href="https://michael.stapelberg.ch/posts/2017-10-22-pkg-go-upstreams/"/>
    <id>https://michael.stapelberg.ch/posts/2017-10-22-pkg-go-upstreams/</id>
    <published>2017-10-22T13:20:00+02:00</published>
    <updated>2019-02-04T19:08:45+01:00</updated>
    <content type="html"><![CDATA[<p>
  In the pkg-go team, we are currently discussing which workflows we should
  standardize on.
</p>

<p>
  One of the considerations is what goes into the “upstream” Git branch of our
  repositories: should it track the upstream Git repository, or should it
  contain orig tarball imports?
</p>

<p>
  Now, tracking the upstream Git repository only works if upstream actually uses
  Git. The go tool, which is widely used within the Go community for managing Go
  packages, supports Git, Mercurial, Bazaar and Subversion. But which of these
  are actually used in practice?
</p>

<p>
  Let’s find out!
</p>

<h3>Option 1: If you have the sources lists of all suites locally anyway</h3>

<pre>
/usr/lib/apt/apt-helper cat-file \
  $(apt-get indextargets --format '$(FILENAME)' 'ShortDesc: Sources' 'Origin: Debian') \
  | sed -n 's,Go-Import-Path: ,,gp' \
  | sort -u
</pre>

<h3>Option 2: If you prefer to use a relational database over textfiles</h3>

<p>
  This is the harder option, but also the more complete one.
</p>

<p>
  First, we’ll need the Go package import paths of all Go packages which are in
  Debian. We can get them from
  the <a href="https://wiki.debian.org/ProjectB">ProjectB</a> database, Debian’s
  main PostgreSQL database containing all of the state about the Debian archive.
</p>

<p>
  Unfortunately, only Debian Developers have SSH access to a mirror of ProjectB
  at the moment. I contacted DSA to ask about providing public ProjectB access.
</p>

<pre>
  ssh mirror.ftp-master.debian.org "echo \"SELECT value FROM source_metadata \
  LEFT JOIN metadata_keys ON (source_metadata.key_id = metadata_keys.key_id) \
  WHERE metadata_keys.key = 'Go-Import-Path' GROUP BY value\" | \
    psql -A -t service=projectb" > go_import_path.txt
</pre>

<p>
  I
  uploaded <a href="https://people.debian.org/~stapelberg/2017-10-22-go_import_path.txt">a
  copy of resulting <code>go_import_path.txt</code></a>, if you’re curious.
</p>

<p>
  Now, let’s come up with a little bit of Go to print the VCS responsible for
  each specified Go import path:
</p>

<pre>
go get -u golang.org/x/tools/go/vcs
cat >vcs4.go <<'EOT'
package main

import (
	"fmt"
	"log"
	"os"
	"sync"

	"golang.org/x/tools/go/vcs"
)

func main() {
	var wg sync.WaitGroup
	for _, arg := range os.Args[1:] {
		wg.Add(1)
		go func(arg string) {
			defer wg.Done()
			rr, err := vcs.RepoRootForImportPath(arg, false)
			if err != nil {
				log.Println(err)
				return
			}
			fmt.Println(rr.VCS.Name)
		}(arg)
	}
	wg.Wait()
}
EOT
</pre>

<p>
  Lastly, run it in combination
  with <a href="https://manpages.debian.org/stretch/coreutils/uniq.1"><code>uniq(1)</code></a>
  to discover…
</p>

<pre>
go run vcs4.go $(tr '\n' ' ' < go_import_path.txt) | sort | uniq -c
    760 Git
      1 Mercurial
</pre>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[pk4: a new tool to avail the Debian source package producing the specified package]]></title>
    <link href="https://michael.stapelberg.ch/posts/2017-10-21-pk4/"/>
    <id>https://michael.stapelberg.ch/posts/2017-10-21-pk4/</id>
    <published>2017-10-21T10:05:00+02:00</published>
    <updated>2019-02-04T19:08:45+01:00</updated>
    <content type="html"><![CDATA[<p>
  UNIX distributions used to come with the system source code
  in <code>/usr/src</code>. This is a concept which fascinates me: if you want
  to change something in any part of your system, just make your change in the
  corresponding directory, recomile, reinstall, and you can immediately see your
  changes in action.
</p>

<p>
  So, I decided I wanted to build a tool which can give you the impression of
  that, without the downsides of additional disk space usage and slower update
  times because of <code>/usr/src</code> maintenance.
</p>

<p>
  The result of this effort is a tool called <code>pk4</code> (mnemonic: get me
  the package for…) which I just uploaded to Debian.
</p>

<p>
  What distinguishes this tool from an <code>apt source</code> call is the
  combination of a number of features:
</p>

<ul>
  <li>
    pk4 defaults to the version of the package which is installed on your
    system. This means when installing the resulting packages, you won’t be
    forced to upgrade your system in case you’re not running the latest
    available version.
    <br>
    In case the package is not installed on your system, the candidate
    (see <code>apt policy</code>) will be used.
  </li>
  <li>
    pk4 tries hard to resolve the provided argument(s): you can specify Debian
    binary package names, Debian source package names, or file paths on your
    system (in which case the owning package will be used).
  </li>
  <li>
    pk4 comes with tab completion for bash and zsh.
  </li>
  <li>
    pk4 caps the disk usage of the checked out packages by deleting the oldest ones
    after crossing a limit (default: 2GiB).
  </li>
  <li>
    pk4 allows users to enable supplied or shipped-with-pk4 hooks, e.g. git-init.
    <br>
    The git-init hook in particular results in an experience that reminds of
    <a href="https://manpages.debian.org/stretch/dgit/dgit.1.en.html">dgit</a>,
    and in fact it might be useful to combine the two tools in some way.
  </li>
  <li>
    pk4 optimizes for low latency of each operation.
  </li>
  <li>
    pk4 respects your APT configuration, i.e. should work in company intranets.
  </li>
  <li>
    tries hard to download source packages, with fallback to snapshot.debian.org.
  </li>
</ul>

<p>
  If you don’t want to wait for the package to clear the NEW queue, you can get
  it from here in the meantime:
</p>
<pre>
wget https://people.debian.org/~stapelberg/pk4/pk4_1_amd64.deb
sudo apt install ./pk4_1_amd64.deb
</pre>

<p>
  You can find the sources and issue tracker
  at <a href="https://github.com/Debian/pk4">https://github.com/Debian/pk4</a>.
</p>

<p>
  Here is a terminal screencast of the tool in action, availing the sources of
  i3, applying a patch, rebuilding the package and replacing the installed
  binary packages:
</p>

<script type="text/javascript" src="https://asciinema.org/a/TgYn2wkABiob14WKb2UefNl9f.js" id="asciicast-TgYn2wkABiob14WKb2UefNl9f" async></script>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Debian stretch on the Raspberry Pi 3 (update)]]></title>
    <link href="https://michael.stapelberg.ch/posts/2017-10-08-raspberry-pi-3/"/>
    <id>https://michael.stapelberg.ch/posts/2017-10-08-raspberry-pi-3/</id>
    <published>2017-10-08T22:45:00+02:00</published>
    <updated>2019-02-04T19:08:45+01:00</updated>
    <content type="html"><![CDATA[<p>
I previously wrote about <a
href="https://people.debian.org/~stapelberg/2017/03/22/raspberry-pi-3.html">my
Debian stretch preview image for the Raspberry Pi 3</a>.
</p>

<p>
Now, I’m publishing an updated version, containing the following changes:
</p>
<ul>
<li>
SSH host keys are generated on first boot.
</li>
<li>
Old kernel versions are now removed from /boot/firmware when purged.
</li>
<li>
The image is built
with <a href="https://github.com/larswirzenius/vmdb2">vmdb2</a>, the successor
to vmdebootstrap. The input files are available
at <a href="https://github.com/Debian/raspi3-image-spec">https://github.com/Debian/raspi3-image-spec</a>.
</li>
<li>
The image uses the linux-image-arm64 4.13.4-3 kernel, which provides HDMI output.
</li>
<li>
The image is now compressed using bzip2, reducing its size to 220M.
</li>
</ul>

<p>
A couple of issues remain, notably the lack of WiFi and bluetooth support
(see <a
href="https://wiki.debian.org/RaspberryPi3">wiki:RaspberryPi3</a> for details.
Any help with fixing these issues is very welcome!
</p>

<p>
As a <strong>preview version</strong> (i.e. unofficial, unsupported, etc.)
until all the necessary bits and pieces are in place to build images in a
proper place in Debian, I built and uploaded the resulting image. Find it at <a
href="https://people.debian.org/~stapelberg/raspberrypi3/2017-10-08/">https://people.debian.org/~stapelberg/raspberrypi3/2017-10-08/</a>.
To install the image, insert the SD card into your computer (I’m assuming it’s
available as <code>/dev/sdb</code>) and copy the image onto it:
</p>

<pre>
$ wget https://people.debian.org/~stapelberg/raspberrypi3/2017-10-08/2017-10-08-raspberry-pi-3-buster-PREVIEW.img.bz2
$ bunzip2 2017-10-08-raspberry-pi-3-buster-PREVIEW.img.bz2
$ sudo dd if=2017-10-08-raspberry-pi-3-buster-PREVIEW.img of=/dev/sdb bs=5M
</pre>

<p>
If resolving client-supplied DHCP hostnames works in your network, you should
be able to log into the Raspberry Pi 3 using SSH after booting it:
</p>

<pre>
$ ssh root@rpi3
# Password is “raspberry”
</pre>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[manpages.debian.org: what’s new since the launch?]]></title>
    <link href="https://michael.stapelberg.ch/posts/2017-04-09-manpages-debian-org-news/"/>
    <id>https://michael.stapelberg.ch/posts/2017-04-09-manpages-debian-org-news/</id>
    <published>2017-04-09T13:23:00+02:00</published>
    <updated>2019-02-04T19:08:45+01:00</updated>
    <content type="html"><![CDATA[<p>
On 2017-01-18, I announced that <a
href="https://manpages.debian.org">https://manpages.debian.org</a> had been
modernized. Let me catch you up on a few things which happened in the meantime:
</p>

<ul>
<li>
Debian experimental was added to manpages.debian.org. I was <a
href="https://github.com/Debian/debiman/issues/23">surprised to learn</a> that
adding experimental only required 52MB of disk usage. Further, Debian contrib
was added after <a href="https://github.com/Debian/debiman/issues/34">realizing
that contrib licenses are compatible with the DFSG</a>.
</li>
<li>
Indentation in some code examples was <a
href="https://github.com/Debian/debiman/issues/21">fixed upstream</a> in
<a href="http://mdocml.bsd.lv">mandoc</a>.
</li>
<li>
Address-bar search should now also work in Firefox, which <a
href="https://github.com/Debian/debiman/issues/41">apparently requires a title
attribute</a> on the opensearch XML file reference.
</li>
<li>
manpages now <a href="https://github.com/Debian/debiman/issues/42">specify
their language</a> in the HTML tag so that search engines can offer users the
most appropriate version of the manpage.
</li>
<li>
I contributed <code>mandocd(8)</code> to the mandoc project, which <a
href="https://github.com/Debian/debiman/commit/3715b1eaf9c1793b9a8c7b1787e2d6511ca2b004">debiman
now uses</a> for significantly faster manpage conversion (useful for disaster
recovery/development). An entire run previously took 2 hours on my workstation.
With this change, it takes merely 22 minutes. The effects are even more
pronounced on manziarly, the VM behind manpages.debian.org.
</li>
<li>
Thanks to Peter Palfrader (weasel) from the Debian System Administrators (DSA)
team, manpages.debian.org is now serving its manpages (and most of its
redirects) from Debian’s static mirroring infrastructure. That way, planned
maintenance won’t result in service downtime. I contributed <a
href="https://anonscm.debian.org/git/mirror/dsa-puppet.git/tree/modules/roles/README.static-mirroring.txt">README.static-mirroring.txt</a>,
which describes the infrastructure in more detail.
</li>
</ul>

<p>
The list above is not complete, but rather a selection of things I found worth
pointing out to the larger public.
</p>

<p>
There are still a few things I plan to work on soon, so stay tuned :).
</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Debian stretch on the Raspberry Pi 3 (update)]]></title>
    <link href="https://michael.stapelberg.ch/posts/2017-03-22-raspberry-pi-3/"/>
    <id>https://michael.stapelberg.ch/posts/2017-03-22-raspberry-pi-3/</id>
    <published>2017-03-22T18:36:00+02:00</published>
    <updated>2019-02-04T19:08:45+01:00</updated>
    <content type="html"><![CDATA[<p>
I previously wrote about <a
href="https://people.debian.org/~stapelberg/2016/11/24/raspberry-pi-3.html">my
Debian stretch preview image for the Raspberry Pi 3</a>.
</p>

<p>
Now, I’m publishing an updated version, containing the following changes:
</p>
<ul>
<li>
A new version of the upstream firmware makes the Ethernet MAC address persist
across reboots.
</li>
<li>
Updated initramfs files (without updating the kernel) are now correctly copied
to the VFAT boot partition.
</li>
<li>
The initramfs’s file system check now works as the required fsck binaries are
now available.
</li>
<li>
The root file system is now resized to fill the available space of the SD card
on first boot.
</li>
<li>
SSH access is now enabled, restricted via iptables to local network source
addresses only.
</li>
<li>
The image uses the linux-image-4.9.0-2-arm64 4.9.13-1 kernel.
</li>
</ul>

<p>
A couple of issues remain, notably the lack of HDMI, WiFi and bluetooth support
(see <a
href="https://wiki.debian.org/RaspberryPi3">wiki:RaspberryPi3</a> for details.
Any help with fixing these issues is very welcome!
</p>

<p>
As a <strong>preview version</strong> (i.e. unofficial, unsupported, etc.)
until all the necessary bits and pieces are in place to build images in a
proper place in Debian, I built and uploaded the resulting image. Find it at <a
href="https://people.debian.org/~stapelberg/raspberrypi3/2017-03-22/">https://people.debian.org/~stapelberg/raspberrypi3/2017-03-22/</a>.
To install the image, insert the SD card into your computer (I’m assuming it’s
available as <code>/dev/sdb</code>) and copy the image onto it:
</p>

<pre>
$ wget https://people.debian.org/~stapelberg/raspberrypi3/2017-03-22/2017-03-22-raspberry-pi-3-stretch-PREVIEW.img
$ sudo dd if=2017-03-22-raspberry-pi-3-stretch-PREVIEW.img of=/dev/sdb bs=5M
</pre>

<p>
If resolving client-supplied DHCP hostnames works in your network, you should
be able to log into the Raspberry Pi 3 using SSH after booting it:
</p>

<pre>
$ ssh root@rpi3
# Password is “raspberry”
</pre>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[manpages.debian.org has been modernized]]></title>
    <link href="https://michael.stapelberg.ch/posts/2017-01-18-manpages-debian-org/"/>
    <id>https://michael.stapelberg.ch/posts/2017-01-18-manpages-debian-org/</id>
    <published>2017-01-18T18:20:00+01:00</published>
    <updated>2019-02-04T19:08:45+01:00</updated>
    <content type="html"><![CDATA[<p>
<a href="https://manpages.debian.org">https://manpages.debian.org</a> has been
modernized! We have just launched a major update to our manpage repository.
What used to be served via a CGI script is now a statically generated website,
and therefore blazingly fast.
</p>

<p>
While we were at it, we have restructured the paths so that we can serve all
manpages, even those whose name conflicts with other binary packages (e.g.
crontab(5) from cron, bcron or systemd-cron). Don’t worry: the old URLs are
redirected correctly.
</p>

<p>
Furthermore, the design of the site has been updated and now includes
navigation panels that allow quick access to the manpage in other Debian
versions, other binary packages, other sections and other languages. Speaking
of languages, the site serves manpages in all their available languages and
respects your browser’s language when redirecting or following a
cross-reference.
</p>

<p>
Much like the Debian package tracker, manpages.debian.org includes packages
from Debian oldstable, oldstable-backports, stable, stable-backports, testing
and unstable. New manpages should make their way onto manpages.debian.org
within a few hours.
</p>

<p>
The generator program (“debiman”) is open source and can be found at <a
href="https://github.com/Debian/debiman">https://github.com/Debian/debiman</a>.
In case you would like to use it to run a similar manpage repository (or
convert your existing manpage repository to it), we’d love to help you out;
just send an email to stapelberg AT debian DOT org.
</p>

<p>
This effort is standing on the shoulders of giants: check out <a
href="https://manpages.debian.org/about.html">https://manpages.debian.org/about.html</a>
for a list of people we thank.
</p>

<p>
We’d love to hear your feedback and thoughts. Either contact us via an
issue on <a
href="https://github.com/Debian/debiman/issues/">https://github.com/Debian/debiman/issues/</a>,
or send an email to the debian-doc mailing list (see <a
href="https://lists.debian.org/debian-doc/">https://lists.debian.org/debian-doc/</a>).
</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Debian package build tools]]></title>
    <link href="https://michael.stapelberg.ch/posts/2016-11-25-build-tools/"/>
    <id>https://michael.stapelberg.ch/posts/2016-11-25-build-tools/</id>
    <published>2016-11-25T13:30:00+02:00</published>
    <updated>2019-02-04T19:08:45+01:00</updated>
    <content type="html"><![CDATA[<p>
Personally, I find the packaging tools which are available in Debian
<strong>far too complex</strong>. To better understand the options we have, I
created a diagram of tools which are frequently used, only covering the build
step (i.e. no post-build quality assurance checks or packaging-time helpers):
</p>

<a href="https://people.debian.org/~stapelberg/build-tools/2016-11-25-debian-build-tools.png"><img src="https://people.debian.org/~stapelberg/build-tools/2016-11-25-debian-build-tools.png" width="600" alt="debian package build tools"></a>

<p>
When I was first introduced to Debian packaging, people recommended I use
<code>pbuilder</code>. Given how complex the toolchain is in the pbuilder case,
I don’t understand why that is (was?) a common recommendation.
</p>

<p>
Back in August 2015, so well over a year ago, I switched to
<code>sbuild</code>, motivated by how much simpler it was to implement <a
href="https://people.debian.org/~stapelberg//2015/10/12/ratt.html">ratt
(rebuilds reverse build dependencies)</a> using sbuild, and I have not looked
back.
</p>

<p>
Are there people who do not use sbuild for reasons other than familiarity? If
so, please let me know, I’d like to understand.
</p>

<p>
I also made a version of the diagram above, colored by the programming
languages in which the tools are implemented. The chosen colors are heavily
biased :-).
</p>

<a href="https://people.debian.org/~stapelberg/build-tools/2016-11-25-debian-build-tools-lang.png"><img src="https://people.debian.org/~stapelberg/build-tools/2016-11-25-debian-build-tools-lang.png" width="600" alt="debian package build tools, by language"></a>

<p>
To me, the diagram above means: if you want to make substantial changes to the
Debian build tool infrastructure, you need to become an expert in all of
Python, Perl, Bash, C and Make. I know that this is not true for every change,
but it still irks me that there might be changes for which it is required.
</p>

<p>
I propose to eliminate complexity in Debian by deprecating the pbuilder
toolchain in favor of sbuild.
</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Debian stretch on the Raspberry Pi 3]]></title>
    <link href="https://michael.stapelberg.ch/posts/2016-11-24-raspberry-pi-3/"/>
    <id>https://michael.stapelberg.ch/posts/2016-11-24-raspberry-pi-3/</id>
    <published>2016-11-24T09:45:00+02:00</published>
    <updated>2019-02-04T19:08:45+01:00</updated>
    <content type="html"><![CDATA[<p>
The last couple of days, I worked on getting Debian to run on the Raspberry Pi
3.
</p>

<p>
Thanks to the work of many talented people, the Linux kernel in version 4.8 is
_almost_ ready to run on the Raspberry Pi 3. The only missing thing is the
bcm2835 MMC driver, which is required to read the root file system from the SD
card. I’ve asked our maintainers to <a
href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=845422">include the
patch</a> for the time being.
</p>

<p>
Aside from the kernel, one also needs a working bootloader, hence I used
Ubuntu’s linux-firmware-raspi2 package and uploaded the <a
href="https://anonscm.debian.org/cgit/pkg-raspi/linux-firmware-raspi3.git/">linux-firmware-raspi3
package</a> to Debian. The package is currently in the NEW queue and needs to
be accepted by ftp-master before entering Debian.
</p>

<p>
The most popular method of providing a Linux distribution for the Raspberry Pi
is to provide an image that can be written to an SD card. I made two little
changes to vmdebootstrap (<a
href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=845439">#845439</a>, <a
href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=845526">#845526</a>)
which make it easier to create such an image.
</p>

<p>
The Debian wiki page <a
href="https://wiki.debian.org/RaspberryPi3">https://wiki.debian.org/RaspberryPi3</a>
describes the current state of affairs and should be updated, as this blog post
will not be updated.
</p>

<p>
As a <strong>preview version</strong> (i.e. unofficial, unsupported, etc.)
until all the necessary bits and pieces are in place to build images in a
proper place in Debian, I built and uploaded the resulting image. Find it at <a
href="https://people.debian.org/~stapelberg/raspberrypi3/">https://people.debian.org/~stapelberg/raspberrypi3/</a>.
To install the image, insert the SD card into your computer (I’m assuming it’s
available as <code>/dev/sdb</code>) and copy the image onto it:
</p>

<pre>
$ wget https://people.debian.org/~stapelberg/raspberrypi3/2016-11-24-raspberry-pi-3-stretch-PREVIEW.img
$ sudo dd if=2016-11-24-raspberry-pi-3-stretch-PREVIEW.img of=/dev/sdb bs=5M
</pre>

<p>
I hope this initial work on getting Debian booted will motivate other people to
contribute little improvements here and there. A list of current limitations
and potential improvements can be found on the <a
href="https://wiki.debian.org/RaspberryPi3">RaspberryPi3 Debian wiki page</a>.
</p>
]]></content>
  </entry>
</feed>
